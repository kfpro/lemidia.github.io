I"9<h1 id="깊이우선탐색depth-first-search-dfs">깊이우선탐색(Depth First Search, DFS)</h1>

<p>깊이우선탐색(DFS)은 트리나 그래프 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 대게 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트노드로 정하게 된다.) 탐색을 하다가 더 이상 갈 수 없어 백트랙 하기 전까지 가능한 한 가지를 따라 깊게 멀리 탐색한다.</p>

<p>시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 DFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 DFS는 현재 탐색하고 있는 경로의 정점들과 이미 방문한 정점들의 스택을 저장하고 있기 때문에 최악 $O(|V|)$의 공간을 요구한다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)</p>

<p>깊이우선탐색(DFS)의 시간 및 공간 상한은 너비우선탐색(BFS)과 같기 때문에, 탐색 알고리즘의 사용면에서 두 알고리즘이 만드는 정점 방문 순서의 다름과 그 복잡성을 생각해 어느 알고리즘을 사용해야 할지 생각해야한다.</p>

<h2 id="예제">예제</h2>

<p>다음 그래프를 보고 깊이우선탐색이 어떤 것인지 이해해보자.</p>

<p><img src="/assets/images/DFS1.png" alt="Alt text" width="300px" height="300px" class="align-center" /></p>

<p><strong>가정</strong></p>

<ul>
  <li>현재 방문하고 있는 정점에서 인접한 왼쪽 간선을 오른쪽 간선보다 먼저 선택한다고 가정한다.</li>
  <li>탐색 알고리즘은 현재 정점의 이전 정점의 방문을 기억한다고 가정한다.</li>
  <li>정점들의 방문은 중복되지 않는다고 가정한다.</li>
</ul>

<hr />

<p>먼저 A를 루트 노드로 하여 탐색을 시작한다.</p>

<ol>
  <li>
    <p>A를 방문하고 위의 가정에 따라 인접 정점 C, E를 탐색하기 전에 B를 먼저 탐색한다.</p>
  </li>
  <li>
    <p>B를 방문하고 F를 탐색하기 전에 D를 먼저 탐색한다.</p>
  </li>
  <li>
    <p>D를 방문하고 D의 인접한 정점은 B이지만 이미 방문하였기에 더 이상 탐색할 곳이 없으므로, 이전 정점 B로 백트래킹 한다.</p>
  </li>
  <li>
    <p>정점 B에서 F를 탐색한다.</p>
  </li>
  <li>
    <p>F를 방문하고 아직 탐색하지 않은 인접 정점인 E를 탐색한다.</p>
  </li>
  <li>
    <p>E를 방문하고 나면 인접 정점들은 모두 방문한 상태이므로 이전 정점 F로 백트래킹 한다.</p>
  </li>
  <li>
    <p>F에서도 인접 정점들은 모두 방문한 상태이므로 이전 정점 B로 백트래킹 한다.</p>
  </li>
  <li>
    <p>B에서도 인접 정점들은 모두 방문한 상태이므로 이전 정점 A로 백트래킹 한다.</p>
  </li>
  <li>
    <p>A에서 인접한 정점 중 아직 탐색하지 않은 곳은 C이므로 C를 탐색한다.</p>
  </li>
  <li>
    <p>C를 방문하고 아직 탐색하지 않은 곳인 G를 탐색한다.</p>
  </li>
  <li>
    <p>G를 방문한다.</p>
  </li>
  <li>
    <p>G에서 인접 정점들은 모두 방문한 상태이므로 이전 정점 C로 백트래킹 한다.</p>
  </li>
  <li>
    <p>C에서 인접 정점들은 모두 방문한 상태이므로 이전 정점 A로 백트래킹 한다.</p>
  </li>
  <li>
    <p>A에서 모든 인접 정점이 방문 완료 되었으므로 DFS는 완료되었다.</p>
  </li>
</ol>

<p><strong>이로서, DFS에 의한 위 그래프의 정점들 방문 순서는 : A, B, D, F, E, C, G 이다.</strong></p>

<h2 id="의사코드">의사코드</h2>

<p>다음은 깊이우선탐색의 의사코드이다.</p>

<hr />

<p>Input: 그래프 G, 그래프 G의 정점 v<br />
Output: v로 부터 탐색 가능한 모든 정점들</p>

<p>DFS의 재귀적 구현 의사코드이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">is</span>
    <span class="n">label</span> <span class="n">v</span> <span class="n">as</span> <span class="n">discovered</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">directed</span> <span class="n">edges</span> <span class="n">from</span> <span class="n">v</span> <span class="n">to</span> <span class="n">w</span> <span class="n">that</span> <span class="n">are</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">adjacentEdges</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="n">w</span> <span class="n">is</span> <span class="n">not</span> <span class="n">labeled</span> <span class="n">as</span> <span class="n">discovered</span> <span class="n">then</span>
            <span class="n">recursively</span> <span class="n">call</span> <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</code></pre></div></div>

<p>한 구문씩 보자.</p>

<ul>
  <li><code class="highlighter-rouge">label v as discovered</code> v를 탐색했다는 것을 표시한다. (중복방문 방지)</li>
  <li><code class="highlighter-rouge">for all directed edges from v to w that are in G.adjacentEdges(v) do</code></li>
</ul>
:ET