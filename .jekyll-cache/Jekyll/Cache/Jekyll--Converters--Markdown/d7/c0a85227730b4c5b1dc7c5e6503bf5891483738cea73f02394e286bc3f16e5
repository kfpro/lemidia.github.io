I"s<h1 id="bubble버블-정렬">Bubble(버블 정렬)</h1>

<p>비교 기반 정렬 알고리즘이다.</p>

<p>다른 O(nlongn)의 성능을 내는 정렬 알고리즘에 비해 성능이 좋지 않으므로 실무에서는 교육용 목적으로 사용 되어진다.</p>

<p class="notice--info">더 효율적인 정렬 알고리즘인 팀소트(Timsort)가 머지소트(Merge sort)는 인기있는 프로그래밍 언어(java, python)의 내장 정렬 라이브러리로 사용되고 있다.</p>
<hr />

<h2 id="algorithm">Algorithm</h2>

<p>밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.</p>

<ol>
  <li>처음 원소를 시작으로 n번째 원소까지 차례대로 옆 원소와 오른쪽으로 비교하며 스왑을 진행한다.</li>
  <li>n번째 원소와 비교가 끝이나면 n번째 원소는 정렬이 완료된 것이다.</li>
  <li>처음 원소부터 n-1번째 원소까지 1번과 같이 수행한다.</li>
  <li>n-1번째 원소와 비교가 끝이나면 n-1번째 원소는 정렬이 완료된 것이다.</li>
  <li>이를 반복하여 n-2..n-3..2번째 원소까지 정렬이 완료되면 정렬이 완료된 것이다.</li>
</ol>

<p><img src="/assets/images/bubblesort1.gif" alt="Alt text" width="400px&quot;, height=&quot;500px" /></p>

<h2 id="analysis">Analysis</h2>

<p>버블소트는 최악과 평균 시간복잡도가 $O(n^2)$인 정렬 알고리즘이다.</p>

<p>최악과 평균 시간복잡도가 $O(nlog_{2}n)$인 실용적인 정렬 알고리즘 보다 성능이 좋지않고<br />
시간복잡도가 $O(n^2)$인 삽입정렬도 버블소트보다는 빠르게 동작하기 때문에 버블소트는 다소 실용적인 정렬 알고리즘이 아니다.</p>

<p>다른 정렬들과 비교해(삽입정렬을 제외한) 버블소트의 최대 장점은 배열이 정렬되어 있는 것을 탐지해낼 수 있는 능력이다.</p>

<p>리스트가 정렬이 완료되어 있을 때의 버블정렬은 O(n)이다.</p>

<h2 id="step-by-step-example">Step-by-step example</h2>

<p>배열 “5 1 4 2 8” 있다고 하자.<br />
처음 원소부터 끝 원소까지 오름차순으로 버블소트를 이용하여 정렬하려고 한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>첫번째 패스 

( 5 1 4 2 8 ) → ( 1 5 4 2 8 )  
첫번째 원소와 두번째 원소를 비교한다, 5 &gt; 1 이므로 스왑한다. 
( 1 5 4 2 8 ) → ( 1 4 5 2 8 )  
Swap since 5 &gt; 4  
( 1 4 5 2 8 ) → ( 1 4 2 5 8 )  
Swap since 5 &gt; 2  
( 1 4 2 5 8 ) → ( 1 4 2 5 8 )  
Now, since these elements are already in order (8 &gt; 5)  
algorithm does not swap them.

Second Pass

( 1 4 2 5 8 ) → ( 1 4 2 5 8 )  
( 1 4 2 5 8 ) → ( 1 2 4 5 8 )  
Swap since 4 &gt; 2  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  

Now, the array is already sorted,  
but the algorithm does not know if it is completed.  
The algorithm needs one whole pass without  
any swap to know it is sorted.  

Third Pass

( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )  
</code></pre></div></div>

<h2 id="implementation">Implementation</h2>

<p>Pseudocode implementation</p>

<p>In pseudocode the algorithm can be expressed as (0-based array):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure bubbleSort(A : list of sortable items)
    n := length(A)
    repeat
        swapped = false
        for i := 1 to n - 1 inclusive do
            /* if this pair is out of order */
            if A[i - 1] &gt; A[i] then
                /* swap them and remember something changed */
                swap(A[i - 1], A[i])
                swapped := true
            end if
        end for
    until not swapped
end procedure
</code></pre></div></div>

<p>Optimizing bubble sort</p>

<p>The bubble sort algorithm can be easily optimized by observing that the n-th pass finds the n-th largest element and puts it into its final place. So, the inner loop can avoid looking at the last n − 1 items when running for the n-th time:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure bubbleSort(A : list of sortable items)
    n := length(A)
    repeat
        swapped := false
        for i := 1 to n - 1 inclusive do
            if A[i - 1] &gt; A[i] then
                swap(A[i - 1], A[i])
                swapped = true
            end if
        end for
        n := n - 1
    until not swapped
end procedure
</code></pre></div></div>

<h2 id="시간복잡도">시간복잡도</h2>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최악 시간복잡도	$O(n^2)$
최선 시간복잡도	$O(n)$
평균 시간복잡도	$O(n^2)$
</code></pre></div></div>

<h2 id="references">References</h2>

<p>[Bubble Sort - wikipedia]</p>
:ET