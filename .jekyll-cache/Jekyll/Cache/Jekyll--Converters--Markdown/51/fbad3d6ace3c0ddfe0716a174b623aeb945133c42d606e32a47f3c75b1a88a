I"K5<h1 id="bubble버블-정렬">Bubble(버블 정렬)</h1>

<p>비교 기반 정렬 알고리즘이다.</p>

<p>다른 O(nlongn)의 성능을 내는 정렬 알고리즘에 비해 성능이 좋지 않으므로 실무에서는 교육용 목적으로 사용 되어진다.</p>

<p class="notice--info">더 효율적인 정렬 알고리즘인 팀소트(Timsort)가 머지소트(Merge sort)는 인기있는 프로그래밍 언어(java, python)의 내장 정렬 라이브러리로 사용되고 있다.</p>
<hr />

<h2 id="algorithm">Algorithm</h2>

<p>밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.</p>

<ol>
  <li>처음 원소를 시작으로 n번째 원소까지 차례대로 옆 원소와 오른쪽으로 비교하며 스왑을 진행한다.</li>
  <li>n번째 원소와 비교가 끝이나면 n번째 원소는 정렬이 완료된 것이다.</li>
  <li>처음 원소부터 n-1번째 원소까지 1번과 같이 수행한다.</li>
  <li>n-1번째 원소와 비교가 끝이나면 n-1번째 원소는 정렬이 완료된 것이다.</li>
  <li>이를 반복하여 n-2..n-3..2번째 원소까지 정렬이 완료되면 정렬이 완료된 것이다.</li>
</ol>

<p><img src="/assets/images/bubblesort1.gif" alt="Alt text" width="400px&quot;, height=&quot;500px" /></p>

<h2 id="analysis">Analysis</h2>

<p>버블소트는 최악과 평균 시간복잡도가 $O(n^2)$인 정렬 알고리즘이다.</p>

<p>최악과 평균 시간복잡도가 $O(nlog_{2}n)$인 실용적인 정렬 알고리즘 보다 성능이 좋지않고<br />
시간복잡도가 $O(n^2)$인 삽입정렬도 버블소트보다는 빠르게 동작하기 때문에 버블소트는 다소 실용적인 정렬 알고리즘이 아니다.</p>

<p>다른 정렬들과 비교해(삽입정렬을 제외한) 버블소트의 최대 장점은 배열이 정렬되어 있는 것을 탐지해낼 수 있는 능력이다.<br />
리스트가 정렬이 완료되어 있을 때의 버블정렬은 O(n)이다.</p>

<h2 id="step-by-step-example">Step-by-step example</h2>
<p>Take an array of numbers “ 5 1 4 2 8”, and sort the array from lowest number to greatest number using bubble sort. In each step, elements written in bold are being compared. Three passes will be required;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>First Pass
( 5 1 4 2 8 ) → ( 1 5 4 2 8 )
Here, algorithm compares the first two elements, and swaps since 5 &gt; 1.
( 1 5 4 2 8 ) → ( 1 4 5 2 8 )
Swap since 5 &gt; 4
( 1 4 5 2 8 ) → ( 1 4 2 5 8 )
Swap since 5 &gt; 2
( 1 4 2 5 8 ) → ( 1 4 2 5 8 )
Now, since these elements are already in order (8 &gt; 5)
algorithm does not swap them.

Second Pass
( 1 4 2 5 8 ) → ( 1 4 2 5 8 )
( 1 4 2 5 8 ) → ( 1 2 4 5 8 )
Swap since 4 &gt; 2
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )

Now, the array is already sorted, 
but the algorithm does not know if it is completed. 
The algorithm needs one whole pass without 
any swap to know it is sorted.

Third Pass
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )
( 1 2 4 5 8 ) → ( 1 2 4 5 8 )

</code></pre></div></div>

<h2 id="implementation">Implementation</h2>

<p>Pseudocode implementation</p>

<p>In pseudocode the algorithm can be expressed as (0-based array):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure bubbleSort(A : list of sortable items)
    n := length(A)
    repeat
        swapped = false
        for i := 1 to n - 1 inclusive do
            /* if this pair is out of order */
            if A[i - 1] &gt; A[i] then
                /* swap them and remember something changed */
                swap(A[i - 1], A[i])
                swapped := true
            end if
        end for
    until not swapped
end procedure
</code></pre></div></div>

<h2 id="java로-구현---재귀적top-down-recursive">Java로 구현 - 재귀적(Top-down, Recursive)</h2>
<p class="notice--warning"><strong>설명</strong>: 재귀적으로 서브배열의 크기가 1이 될 때까지 계속 분할을 진행합니다.<br />
분할된 배열들을 정렬하고 합병합니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @author lemidia</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeSort</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">divide</span><span class="o">(</span><span class="kt">int</span> <span class="n">data</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="o">(</span><span class="n">p</span><span class="o">+</span><span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span> <span class="c1">// Middle</span>
            <span class="n">divide</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span> <span class="c1">// Left</span>
            <span class="n">divide</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span> <span class="c1">// Right</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span> <span class="c1">// Merge</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span> <span class="n">data</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span> <span class="o">;</span> <span class="n">l</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">||</span> <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">])){</span>
                <span class="n">temp</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span>
                <span class="n">temp</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">data</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">;</span> <span class="n">l</span><span class="o">++){</span>
            <span class="n">data</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="cm">/*
        while (i&lt;=q &amp;&amp; j&lt;=r){
            if(data[i] &lt;= data[j]){
                temp[k++] = data[i++];
            }else{
                temp[k++] = data[j++];
            }
        }
        while (i&lt;=q)
            temp[k++] = data[i++];
        while (j&lt;=r)
            temp[k++] = data[j++];
        for(int l = p; l&lt;=r; l++){
            data[l] = temp[l];
        }
        */</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">limit</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">limit</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">){</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">limit</span><span class="o">-</span><span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">divide</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">limit</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> 
</code></pre></div></div>

<h2 id="시간복잡도">시간복잡도</h2>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>최악 시간복잡도	O(n log n)
최선 시간복잡도	O(n log n)
평균 시간복잡도	일반적으로, O(n log n)
</code></pre></div></div>
<p class="notice--warning"><strong>쉬운 설명</strong>: 배열의 원소가 n개일 때 깊이는 log(n)만큼 진행 됩니다. (매번 2개씩 분할 되므로)<br />
각 깊이마다 n개의 원소들이 제자리를 찾아 스왑됩니다.<br />
그래서 시간복잡도는 깊이 * n개의 원소 즉, <strong>nlog(n)</strong>이 됩니다.</p>

<h2 id="references">References</h2>

<p><a href="https://en.wikipedia.org/wiki/Merge_sort">Merge Sort - wikipedia</a></p>
:ET