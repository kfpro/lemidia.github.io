I"q0<h1 id="삽입-정렬insertion-sort">삽입 정렬(Insertion sort)</h1>

<p>삽입 정렬은 <strong>안정 정렬이자 제자리 정렬</strong> 알고리즘이다.</p>

<p>비교적 심플한 정렬 알고리즘으로서 일상 생활에서도 번호에 따라 카드를 정렬할 때 대부분 이 방법을 사용하곤 한다.
이 알고리즘에서는 각 원소를 정렬된 부분 배열(Sorted partial array)의 적절한 위치에 삽입한다.</p>

<p>삽입 정렬의 시간복잡도는 최악 기준 $O(n^2)$이므로 큰 리스트에는 비효율적이며, 유사한 시간복잡도를 갖는 선택 정렬이나 버블소트 보다는 성능이 좋지만, $O(nlogn)$의 시간복잡도를 같는 퀵 소트나 머지소트 같은 소팅 알고리즘 보다는 덜 효율적이다.</p>

<p>그러나, 삽입 정렬은 원소의 숫자가 적은 배열이나 리스트(원소의 개수가 10-20개 이하)에서는 일반적으로 퀵 소트나 머지소트 보다 효율적이여서, 실무에서는 다른 $O(nlongn)$의 시간복잡도를 갖는 소팅 알고리즘과 함께 정렬에 사용되어지고 있다. (ex. Tim sort)</p>

<p><strong>안정 정렬과 제자리 정렬 이란?</strong></p>

<p class="notice--warning"><strong>안정 정렬:</strong> 정렬이 끝나면 <strong>같은 키값</strong>을 가진 원소들의 <strong>상대적인 순서</strong>가 변하지 않는 것을 의미.<br />
안정 정렬 알고리즘으로는 <strong>삽입 정렬, 머지소트, 카운팅 소트</strong> 등이 있다.</p>
<p class="notice--primary"><strong>제자리 정렬:</strong> 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.<br />
예를 들어 <strong>삽입 정렬</strong>은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 <strong>원소가 저장되는 공간과 루프 변수</strong> 정도에 불과하다.</p>

<p><strong>다음은 삽입 정렬의 몇 가지 장점이다.</strong></p>

<ul>
  <li>다른 정렬 알고리즘에 비해 코드가 간단하고 구현이 쉽다.</li>
  <li>이차항의 시간복잡도$O(n^2)를 가지는(선택 정렬, 버블 소트) 다른 소팅 알고리즘에 비해 비교적 효율적이다.</li>
  <li>작은 데이터 셋에서 매우 효율적이다.</li>
  <li>적응적이다. 대체로 이미 정렬이 데이터 셋에서는 효율적이다.</li>
  <li>같은 키값을 가진 원소들의 상대적인 순서를 바꾸지 않는다.</li>
  <li>O(1)의 상수적인 추가 메모리 공간만이 필요하다.</li>
  <li>실시간으로 원소를 하나씩 입력받으면서 정렬할 수 있다.</li>
</ul>

<h2 id="알고리즘">알고리즘</h2>

<p>다음은 선택 정렬의 알고리즘이다. (오름차순)</p>

<ol>
  <li>먼저, 정렬될 리스트에서 가장 <strong>최소값</strong>을 찾는다.</li>
  <li>1번에서 찾은 값을 정렬될 리스트의 <strong>맨 처음</strong> 위치한 값과 바꾼다. <strong>(1 pass)</strong></li>
  <li>맨 처음 위치를 제외한 나머지 리스트의 원소들에 대해서 이를 반복한다.</li>
</ol>

<p class="notice--info"><strong>1 pass:</strong> 정렬이 되지않은 리스트에서 최소값을 선택해, 리스트의 적절한 위치에 넣는다.</p>

<p>이처럼, n개의 원소를 가진 리스트는 선택 정렬로 n-1번의 패스를 거쳐 정렬이 된다.</p>

<p>비교하는 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 리스트를 위와 같은 방법으로 정렬하는 데에는 $O(n^2)$ 만큼의 시간이 걸린다.</p>

<hr />

<p>다음은 선택 정렬의 <strong>애니메이션</strong>이다.</p>

<p><img src="/assets/images/Selection-Sort-Animation.gif" alt="alt" width="500px" height="300px" class="align-center" /></p>
<h2 id="예제">예제</h2>

<p>다음 예제를 보고 알고리즘을 이해해 보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>다음과 같은 리스트가 있다고 하자.  

List = [64 25 12 22 11] - index: 0...4

List = [정렬 완료 | 미정렬]

1 pass: List[0...4]를 순회하여 최소값인 11을 찾고  
        이를 0번째 인덱스 위치의 64와 스왑한다.

List = [11 | 25 12 22 64]

2 pass: List[1...4]를 순회하여 최소값인 12을 찾고
        이를 1번째 인덱스 위치의 25와 스왑한다.

List = [11 12 | 25 22 64]

3 pass: List[2...4]를 순회하여 최소값인 22을 찾고  
        이를 2번째 인덱스 위치의 25와 스왑한다.

List = [11 12 22 | 25 64]

4 pass: List[3...4]를 순회하여 최소값인 25을 찾고  
이를 3번째 인덱스 위치의 25와 스왑한다.

List = [11 12 22 25 | 64]

n-1번의 pass로 리스트의 정렬이 완료되었다.
</code></pre></div></div>

<h2 id="구현">구현</h2>

<p>다음은 선택 정렬을 C로 구현한 코드이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* a[0] to a[aLength-1] is the array to sort */</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">aLength</span><span class="p">;</span> <span class="c1">// initialise to a's length</span>

<span class="cm">/* advance the position through the entire array */</span>
<span class="cm">/*   (could do i &lt; aLength-1 because single element is also min element) */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">aLength</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* find the min element in the unsorted a[i .. aLength-1] */</span>

    <span class="cm">/* assume the min is the first element */</span>
    <span class="kt">int</span> <span class="n">jMin</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="cm">/* test against elements after i to find the smallest */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">aLength</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* if this element is less, then it is the new minimum */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">jMin</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="cm">/* found new minimum; remember its index */</span>
            <span class="n">jMin</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">jMin</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">jMin</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<hr />
<p>다음은 선택 정렬을 자바로 구현한 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">selectionSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">indexMin</span><span class="o">,</span> <span class="n">temp</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="c1">// Lowest position</span>
        <span class="n">indexMin</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">[</span><span class="n">indexMin</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">indexMin</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// Swap</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">list</span><span class="o">[</span><span class="n">indexMin</span><span class="o">];</span>
        <span class="n">list</span><span class="o">[</span><span class="n">indexMin</span><span class="o">]</span> <span class="o">=</span> <span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">list</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="시간복잡도--공간복잡도">시간복잡도 &amp; 공간복잡도</h2>

<p><strong>시간복잡도 분석</strong></p>

<p>$n$ $(n-1…1)$개의 원소를 매 패스마다 스캔하여 적절한 위치와 스왑한다.<br />
n개의 원소가 있다면 $n-1$의 패스를 가진다.</p>

<script type="math/tex; mode=display">(n - 1) + (n - 2) +...+ 1 = \sum_{i=1}^{n-1} i</script>

<p>등차수열에 의해,</p>

<script type="math/tex; mode=display">\sum _{i=1}^{n-1}i={\frac {(n-1)+1}{2}}(n-1)={\frac {1}{2}}n(n-1)={\frac {1}{2}}(n^{2}-n)</script>

<p>비교의 측면에서 볼 때, 복잡도는 $O(n^2)$이다.</p>

<p>교환은 매 패스마다 한 번씩 일어난다. 즉, $n-1$번 복잡도는 $O(n)$<br />
(마지막 원소는 이미 정렬되어 있다.)</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>**Selection sort**

Class	            정렬 알고리즘

Data structure	    배열

Worst-case          О(n^2) 비교
performance         О(n) 교환

Best-case           О(n^2) 비교
performance         О(n) 교환

Average             О(n^2) 비교
performance         О(n) 교환

Worst-case          O(1) 추가 공간
space complexity	
</code></pre></div></div>

<h2 id="references">References</h2>

<p><a href="https://en.wikipedia.org/wiki/Selection_sort">Selection sort</a><br />
<a href="https://medium.com/@notestomyself">Selection sort - GIF</a></p>
:ET