I""<h1 id="이분-탐색binary-search">이분 탐색(Binary Search)</h1>

<p>컴퓨터 과학(Computer science)에서 <strong>이분 탐색(Binary Search)</strong>은 <strong>정렬된 배열(Sorted array)</strong>에서 찾고자 하는 값의 <strong>존재 유무나 위치</strong>를 찾는 알고리즘이다. 이분 탐색은 찾고자 하는 값을 배열의 중간 원소와 비교한다. 두 개의 값이 같지 않다면, 찾고자 하는 값이 놓여있지 않다고 판단되는 배열의 반은 탐색 범위에서 제외되고 나머지 반을 다시 탐색한다. 이것을 찾고자 하는 값이 나올 때까지 반복하는데, 탐색 공간이 빈 공간(크기가 0)이 되어 탐색이 끝나게 되면 해당 배열에서 찾고자 하는 값이 없다는 것을 의미한다.</p>

<p>탐색을 수행할 배열의 원소 개수가 $n$개일 때 이분 탐색은 복잡도 면에서 최악의 경우 <strong>$O(logn)$의 로그적</strong> 시간에 동작한다. 앞에서 부터 순서대로 하나씩 탐색하는 순차 혹은 선형 탐색(linear search)과 비교하면 작은 크기의 배열을 제외할 시 이분 탐색이 더 빠르다고 할 수 있다. 순차 탐색은 탐색에 있어 배열의 원소 순서에 제약이 없지만 이분 탐색은 원소의 정렬이 완료된 배열에서 탐색이 가능하다.</p>

<h2 id="algorithm">Algorithm</h2>

<p>가장 일반적인 알고리즘을 보자.</p>

<p>배열은 오름차순으로 정렬되어 있다고 가정하고 시작한다. 먼저 찾고자 하는 값을 배열의 중간 위치의 원소 값과 비교한다. 찾고자 하는 값이 중간 위치의 원소 값과 일치하면 그 중간 원소의 위치를 반환하고 알고리즘을 끝낸다. 찾고자 하는 값이 중간 원소의 값보다 작다면 중간 원소를 기준으로 오른쪽의 값들은 찾고자 하는 값들보다 크므로 탐색을 수행할 필요가 없다. 따라서 왼쪽 반에 대해서 이분 탐색을 수행한다. 찾고자 하는 값이 중간 원소의 값보다 그다면 중간 원소를 기준으로 왼쪽의 값들은 찾고자 하는 값들보다 작으므로 탐색을 수행할 필요가 없다. 따라서 오른쪽 반에 대해서 이분 탐색을 수행한다. 이것을 원하는 값을 찾을 때 까지 수행한다. 탐색을 수행하다가 탐색 범위의 크기가 0이 되면 배열에서 찾고자 하는 값이 없다는 것을 의미한다.</p>

<p>$n$개의 원소로 이루어진 $A_0,A_1,A_2,…,A_{n-1}$ 배열 $A$가 주어지고 원소들은 오름차순 $A_0 \leq A_1 \leq A_2 \leq … \leq A_{n-1}$ 으로 정렬되어 있다. 그리고 찾고자 하는 값 $T$가 주어진다.</p>

<p>다음의 절차로 배열 $A$에서 값 $T$를 찾는다.</p>

<ol>
  <li>
    <p>배열의 맨 처음 인덱스를 가리키는 $L$을 $0$으로 배열의 맨 끝 인덱스를 가리키는 $R$을 $n-1$으로 놓는다.</p>
  </li>
  <li>
    <p>$L \gt R$ 이면 탐색 공간의 크기가 0이 되고 배열에서 찾고자 하는 값이 없다는 것을 의미하므로 알고리즘을 종료한다.</p>
  </li>
  <li>
    <p>그렇지 않다면, 배열의 중간 인덱스 원소를 가리키는 $m$을 $\lfloor\frac{L + R}{2}\rfloor$로 놓는다. $\lfloor\rfloor$, floor 기호는 해당 값 보다 작거나 같은 수 중 가장 큰 정수를 의미한다. 예) $\lfloor\frac{1+2}{2}\rfloor$ = 1이다.</p>
  </li>
  <li>
    <p>$A_m \le T$이면 $L$을 $m+1$로 놓고 2번으로 간다.</p>
  </li>
  <li>
    <p>$A_m \gt T$이면 $R$을 $m-1$로 놓고 2번으로 간다.</p>
  </li>
</ol>
:ET