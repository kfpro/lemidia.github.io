I"<h1 id="recursion">Recursion</h1>
<p>컴퓨터 과학에서의 <strong>Recursion</strong>은 어떤 문제가 그 문제의 <strong>더 작은 사례의 해결</strong>에 의존해 해결되는 방법론이다. 재귀적인 문제는 반복적인 방법으로도 풀어질 수 있는데 그렇게 되기 위해선 런 타임 이전에 더 작은 사례를 식별하고 인덱스화 해야한다. 컴퓨터 과학 그리고 프로그래밍에서 Recursion은 함수가 자기 코드(own code) 안에서 <strong>자기 자신</strong>을 호출함으로 재귀적인 문제를 해결한다. Recursion은 많은 종류의 문제에서 적용될 수 있고 컴퓨터 과학에서의 중요한 이론이므로 잘 알아둘 필요가 있다.</p>

<p>대부분의 프로그래밍 언어는 함수가 자기 코드(own code) 안에서 <strong>자기 자신</strong>을 호출하는 방식으로 재귀를 지원한다. 함수적 프로그래밍 언어는 반복적인 구조를 정의하지 않으므로 오직 재귀적인 방법에만 의존해 문제를 해결한다.</p>

<p>함수안에서 자기 자신을 반복적으로 호출하는 재귀적인 방식을 사용하면 콜스택의 크기가 계속 커져 모든 호출과 연관된 입력 크기의 합과 같아질 수 있고, 이는 반복적인 방법으로 쉽게 해결이 가능한 문제의 경우 재귀를 적용했을 때의 효율성이 떨어진다는 것을 말한다. 또한 재귀적인 방법을 적용할 때 다소 큰 문제에 대해서는 tail call 같은 최적화 기술을 사용하는 것이 필수적이다.</p>

<h2 id="recursive-functions-and-algorithms">Recursive functions and algorithms</h2>

<h2 id="references">References</h2>

<p><a href="https://en.wikipedia.org/wiki/Quicksort#Analysis_of_randomized_quicksort">Quick sort - wikipedia</a><br />
<a href="https://www.codingeek.com/algorithms/quick-sort-algorithm-explanation-implementation-and-complexity/">Quick sort - codingeek</a><br />
<a href="https://www.programiz.com/dsa/quick-sort">Quick sort - programiz</a></p>
:ET