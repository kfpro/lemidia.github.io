I"W,<h1 id="깊이우선탐색depth-first-search-dfs">깊이우선탐색(Depth First Search, DFS)</h1>

<p>깊이우선탐색(DFS)은 트리나 그래프 혹은 다른 구조 상에서 탐색을 위한 알고리즘이다. 이 알고리즘은 루트 노드를 시작으로(그래프의 경우에는 임의의 노드를 루트 노드로 정하게 된다.) 탐색을 하다가 더 이상 갈 수 없어 백트랙 하기 전까지 가능한 한 가지를 따라 깊게 멀리 탐색한다.</p>

<p>시간 및 공간 복잡도 분석은 많은 응용분야에 따라 다른데, 이론적인 컴퓨터 과학 분야에서 DFS는 전체 그래프를 탐색하는데 사용되기 때문에 수행 시간은 선형인 $O(|V|+|E| )$가 된다. 공간 복잡도면을 보면 DFS는 경로상의 현재 탐색하고 있는 정점과 경로상 이미 방문한 정점들의 스택을 저장하고 있기 때문에 최악 $O(|V|)$의 공간을 요구한다. ($|V|$는 정점의 수, $|E|$는 간선의 수이다.)</p>

<p>깊이우선탐색(DFS)의 시간 및 공간 상한은 너비우선탐색(BFS)과 같기 때문에, 탐색 알고리즘의 사용면에서 두 알고리즘이 만드는 정점 방문 순서의 다름과 그 복잡성을 생각해 어느 알고리즘을 사용해야 할지 생각해야한다.</p>

<h2 id="예제">예제</h2>

<p>다음 그래프를 보고 깊이우선탐색이 어떤 것인지 이해해보자.</p>

<p><img src="/assets/images/DFS1.png" alt="Alt text" width="300px" height="300px" class="align-center" /></p>

<p><strong>가정</strong></p>

<ul>
  <li>현재 방문하고 있는 정점에서 인접한 왼쪽 간선을 오른쪽 간선보다 먼저 선택한다고 가정한다.</li>
  <li>탐색 알고리즘은 현재 정점의 이전 정점의 방문을 기억한다고 가정한다.</li>
  <li>정점들의 방문은 중복되지 않는다고 가정한다.</li>
</ul>

<hr />

<p>먼저 A를 루트 노드로 하여 탐색을 시작한다.</p>

<ol>
  <li>
    <p>A를 방문하고 위의 가정에 따라 인접 정점 C, E를 탐색하기 전에 B를 먼저 탐색한다.</p>
  </li>
  <li>
    <p>B를 방문하고 F를 탐색하기 전에 D를 먼저 탐색한다.</p>
  </li>
  <li>
    <p>D를 방문하고 D의 인접한 정점은 B이지만 이미 방문하였기에 더 이상 탐색할 곳이 없으므로, 이전 정점 B로 백트래킹 한다.</p>
  </li>
  <li>
    <p>정점 B에서 F를 탐색한다.</p>
  </li>
  <li>
    <p>F를 방문하고 아직 탐색하지 않은 인접 정점인 E를 탐색한다.</p>
  </li>
  <li>
    <p>E를 방문하고 나면 인접 정점들은 모두 방문한 상태이므로 이전 정점 F로 백트래킹 한다.</p>
  </li>
  <li>
    <p>F에서도 인접 정점들은 모두 방문한 상태이므로 이전 정점 B로 백트래킹 한다.</p>
  </li>
  <li>
    <p>B에서도 인접 정점들은 모두 방문한 상태이므로 이전 정점 A로 백트래킹 한다.</p>
  </li>
  <li>
    <p>A에서 인접한 정점 중 아직 탐색하지 않은 곳은 C이므로 C를 탐색한다.</p>
  </li>
  <li>
    <p>C를 방문하고 아직 탐색하지 않은 곳인 G를 탐색한다.</p>
  </li>
  <li>
    <p>G를 방문한다.</p>
  </li>
  <li>
    <p>G에서 인접 정점들은 모두 방문한 상태이므로 이전 정점 C로 백트래킹 한다.</p>
  </li>
  <li>
    <p>C에서 인접 정점들은 모두 방문한 상태이므로 이전 정점 A로 백트래킹 한다.</p>
  </li>
  <li>
    <p>A에서 모든 인접 정점이 방문 완료 되었으므로 DFS는 완료되었다.</p>
  </li>
</ol>

<p><strong>이로서, DFS에 의한 위 그래프의 정점들 방문 순서는 : A, B, D, F, E, C, G 이다.</strong></p>

<h2 id="의사코드">의사코드</h2>

<p><strong>깊이우선탐색(DFS)을 하는 두가지 방법을 알아본다.</strong></p>

<h3 id="서브루틴을-이용한-재귀적-방법">서브루틴을 이용한 재귀적 방법</h3>

<p>Input: 그래프 G, 그래프 G의 정점 v<br />
Output: v로 부터 탐색 가능한 모든 정점들</p>

<p>다음은 서브루틴을 이용한 재귀적 방법의 의사코드이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">is</span>
    <span class="n">label</span> <span class="n">v</span> <span class="n">as</span> <span class="n">discovered</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">directed</span> <span class="n">edges</span> <span class="n">from</span> <span class="n">v</span> <span class="n">to</span> <span class="n">w</span> <span class="n">that</span> <span class="n">are</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">adjacentEdges</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="n">w</span> <span class="n">is</span> <span class="n">not</span> <span class="n">labeled</span> <span class="n">as</span> <span class="n">discovered</span> <span class="n">then</span>
            <span class="n">recursively</span> <span class="n">call</span> <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</code></pre></div></div>

<p>한 구문씩 보자.</p>

<ul>
  <li><code class="highlighter-rouge">label v as discovered</code>: 현재 정점 v를 탐색완료 되었다는 것을 표시한다. (중복 방문 방지를 위해)</li>
  <li><code class="highlighter-rouge">for all directed edges from v to w that are in G.adjacentEdges(v) do</code>: 그래프 G의 모든 인접한 간선 (v, w)에 대해서</li>
  <li><code class="highlighter-rouge">if vertex w is not labeled as discovered then</code>: 만약 w가 탐색되지 않았으면</li>
  <li><code class="highlighter-rouge">recursively call DFS(G, w)</code>: 재귀적으로 w를 탐색한다.<br />
이것은 현재 정점 v의 인접 정점 w를 매개변수로 하여 같은 서브루틴으로 다음 정점을 탐색하는 것을 의미한다.</li>
</ul>

<p>이 방법의 최악 공간 복잡도는 $O(|V|)$가 된다.<br />
현재 탐색하고 있는 경로의 정점들과 이미 방문한 정점들의 스택을 저장하고 있기 때문이다.</p>

<h3 id="스택을-이용한-반복적인-방법">스택을 이용한 반복적인 방법</h3>

<p>Input: 그래프 G, 그래프 G의 정점 v<br />
Output: v로 부터 탐색 가능한 모든 정점들</p>

<p>다음은 스택을 이용한 반복적인 방법의 의사코드이다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">DFS</span><span class="o">-</span><span class="n">iterative</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">is</span>
    <span class="n">let</span> <span class="n">S</span> <span class="n">be</span> <span class="n">a</span> <span class="n">stack</span>
    <span class="n">S</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">S</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span> <span class="k">do</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">S</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">v</span> <span class="n">is</span> <span class="n">not</span> <span class="n">labeled</span> <span class="n">as</span> <span class="n">discovered</span> <span class="n">then</span>
            <span class="n">label</span> <span class="n">v</span> <span class="n">as</span> <span class="n">discovered</span>
            <span class="k">for</span> <span class="n">all</span> <span class="n">edges</span> <span class="n">from</span> <span class="n">v</span> <span class="n">to</span> <span class="n">w</span> <span class="n">in</span> <span class="n">G</span><span class="p">.</span><span class="n">adjacentEdges</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">do</span> 
                <span class="n">S</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</code></pre></div></div>

<p>한 구문씩 보자.</p>

<ul>
  <li><code class="highlighter-rouge">let S be a stack</code>: S라는 스택을 하나 생성한다. 현재 방문 정점의 인접 정점들을 담는다.</li>
  <li><code class="highlighter-rouge">S.push(v)</code>: 탐색하고자 하는 시작 정점 v를 스택에 push한다.</li>
  <li>while S is not empty do: 스택이 빈 공간이 아닐 때 까지 아래 연산들을 반복한다.
<code class="highlighter-rouge">v = S.pop()</code>: 현재 탐색 하고 있는 정점을 v에 넣는다.</li>
  <li><code class="highlighter-rouge">if v is not labeled as discovered then label v as discovered</code>: 만약 v가 탐색되지 않았으면, 탐색 완료 표시를 한다.</li>
  <li><code class="highlighter-rouge">for all edges from v to w in G.adjacentEdges(v) do 
              S.push(w)</code>: 현재 정점 v의 모든 인접한 정점 w를 스택에 넣는다.</li>
</ul>

<p>이 방법의 최악 공간 복잡도는 $O(|E|)$가 된다.<br />
재귀적인 방법과는 달리, 어떤 해당 정점에서 인접 정점들의 정보를 모두 스택에 저장하기 때문에, 최악의 설정으로 하나의 정점이 다른 모든 정점과 직접 연결되어 있다면 공간 복잡도는 $O(|E|)$가 된다.</p>

<h3 id="두-가지-접근의-차이점">두 가지 접근의 차이점</h3>

<p>위에서 살펴본 두 가지 DFS의 탐색 방법은 각 정점들의 이웃방문 순서가 서로 반대인데, 재귀적인 방법에서는 인접리스트 방식에서 정점 v의 첫번째 이웃을 먼저 방문하는 반면, 스택을 이용한 반복적인 방법에서는 정점 v의 이웃들이 스택에 역순으로 저장되기 때문에 인접 리스트 관점에서 정점 v의 첫번째 이웃은 제일 마지막(first in last out)에 탐색이 된다.</p>

<p>위 그래프를 예로 들면 재귀적인 방법으로의 방문 순서는 A, B, D, F, E, C, G가 되고,<br />
 스택을 이용한 반복적 접근에서는 A, E, F, B, D, C, G가 된다.</p>

<h2 id="응용">응용</h2>

<p>DFS 탐색 알고리즘은 많은 곳에서 쓰이는데 예는 다음과 같다.</p>

<ul>
  <li>미로 찾기</li>
  <li>그래프의 위상 정렬</li>
  <li>모든 경우 다 해보기(전체 탐색)</li>
  <li>연결 구성 요소 찾기</li>
  <li>이분 그래프</li>
</ul>

<h2 id="references">References</h2>

<p><a href="https://en.wikipedia.org/wiki/Depth-first_search#Properties">Wikipedia</a><br />
<a href="https://www.javatpoint.com/depth-first-search-algorithm">Depth First Search</a></p>
:ET