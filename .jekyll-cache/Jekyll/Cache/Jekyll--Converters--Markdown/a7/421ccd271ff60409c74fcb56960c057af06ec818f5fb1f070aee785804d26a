I"ZI<h1 id="위상정렬topological-sorting">위상정렬(Topological sorting)</h1>

<p>컴퓨터 과학에서 <strong>위상정렬(Topological sorting)</strong>은 방향 그래프에서 정점들의 <strong>선형적인 순서</strong>를 말하는데, 여기서 정점들의 선형적 순서란 정점 u로 부터 정점 v로 가는 간선에 대해 순서상 정점 u가 정점 v보다 앞에 있다는 것을 뜻한다. 예를 들어, 방향 그래프에서 정점들은 수행될 작업들을 뜻할 수 있고, 간선은 어떤 작업이 다른 작업보다 먼저 수행되어야 한다는 제약을 나타낼 수 있다. 즉, 위상정렬의 결과는 작업들이 수행되는 일련의 순서를 의미한다. <strong>위상정렬은 사이클이 형성되지 않은 그래프</strong>에서 가능하다. 즉, 사이클이 없는 방향 그래프에서 적용이 가능한데, 이런 그래프를 DAG(Directed acyclic graph)라고 한다. 어떤 DAG에 대해서도 위상정렬을 적용하면 적어도 하나의 위상순서를 가지게 되고 경우에 따라 여러개의 위상순서를 가지리 수 있다. 위상정렬 알고리즘은 DAG에서 위상순서를 구하는데 선형시간이 걸린다고 알려져 있다.</p>

<h2 id="example">Example</h2>

<p>위상정렬은 현실적인 예로는 제약에 따른 작업들의 스케줄링 순서라고 이해하면 된다. 작업들은 정점으로 나타내어지고 정점에서 다른 정점으로의 간선이 있는데, 이는, x, y 두 정점을 끝 점으로 하고 x-&gt;y로의 방향 간선 E(x,y)이 있을 때 작업 y가 수행되기 위해서는 x가 사전에 먼저 수행 완료되어야 한다는 것을 뜻한다. 작업 y의 제약은 x인 것이다. 이처럼 제약이 있는 해당 작업들에 대해서 위상정렬은 작업들의 수행순서를 나타낸다.</p>

<p>밑 그림에서 5번 정점과 11번 정점을 보자. 정점은 작업으로 생각하고 간선은 제약 또는 작업 흐름으로 보면 위상정렬에서는 5번 작업이 완료되고 11번 작업이 수행된다는 것이다. 즉, 11번 작업이 수행되기 위해선 5번 작업이 사전에 완료가 되어야 한다는 것을 말한다. 다른 작업들도 마찬가지로, 9번 정점이 수행되기 위해서는 11번과 8번 작업이 사전에 완료가 되어야 한다.</p>

<p><img src="/assets/images/topological-sort0.png" alt="alt" width="300px" height="200px" class="align-center" /></p>

<p>다음은 위 그림에서의 위상정렬 순서인데 기준에 따라 여러가지가 있을 수 있다.</p>

<ul>
  <li>5-&gt;7-&gt;3-&gt;11-&gt;8-&gt;2-&gt;9-&gt;10 (왼쪽에서 오른쪽, 밑에서 아래로)</li>
  <li>3-&gt;5-&gt;7-&gt;8-&gt;11-&gt;2-&gt;9-&gt;10 (현재 작업 가능한 작업들의 번호가 작은순서)</li>
</ul>

<p><strong>안정 정렬과 제자리 정렬 이란?</strong></p>

<p class="notice--warning"><strong>안정 정렬:</strong> 정렬이 끝나면 <strong>같은 키값</strong>을 가진 원소들의 <strong>상대적인 순서</strong>가 변하지 않는 것을 의미.<br />
안정 정렬 알고리즘으로는 <strong>삽입 정렬, 머지소트, 카운팅 소트</strong> 등이 있다.</p>
<p class="notice--primary"><strong>제자리 정렬:</strong> 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.<br />
예를 들어 <strong>삽입 정렬</strong>은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 <strong>원소가 저장되는 공간과 루프 변수</strong> 정도에 불과하다.</p>

<p><strong>다음은 삽입 정렬의 몇 가지 장점이다.</strong></p>

<ul>
  <li>다른 정렬 알고리즘에 비해 코드가 간단하고 구현이 쉽다. - Simple to implement</li>
  <li>최악 기준 $O(n^2)$의 시간복잡도를 가지는 소팅 알고리즘(선택 정렬, 버블 소트)에 비해 비교적 효율적이다.</li>
  <li>작은 데이터 셋에서 매우 효율적이다. - Efficient in small data set</li>
  <li>적응적이다. 대체로 이미 정렬이 되어있는 데이터 셋에서 효율적이다. - Adaptive</li>
  <li>같은 키값을 가진 원소들의 상대적인 순서를 바꾸지 않는다. - Stable</li>
  <li>O(1)의 상수적인 추가 메모리 공간만이 필요하다. - In-place</li>
  <li>실시간으로 원소를 하나씩 입력받으면서 정렬할 수 있다. - Online</li>
</ul>

<h2 id="알고리즘">알고리즘</h2>

<p><strong>다음은 삽입 정렬의 알고리즘이다. (오름차순, 원소 개수 2개 이상 기준)</strong></p>

<ol>
  <li>먼저, 정렬될 리스트에서 두번째 원소를 선택한다.</li>
  <li>1.번에서 선택한 원소를 기준으로 리스트의 앞의 원소들과 비교하여 기준에 따라 자기 자리를 찾아간다. - 1 pass</li>
  <li>이를 매번 3…n-1번째 원소까지 선택하여 2.번을 반복한다.</li>
</ol>

<p>이처럼, n개의 원소를 가진 리스트는 삽입 정렬로 n-1번의 패스를 거쳐 정렬이 된다.</p>

<hr />

<p>삽입 정렬에서는 <strong>매 반복(1 pass or each repetition)마다</strong> 하나의 원소를 취해 부분 정렬된 정렬된 리스트에 그 원소가 속할 위치를 찾고 그 위치에 삽입을 한다. 이것을 n번째 원소까지 반복한다.</p>

<p>다음 그림은 매번의 반복마다 원소 $x$가 자리를 찾아 삽입되는 것을 보여준다.</p>

<p>아래 그림은 원소 $x$가 정렬이 수행되기 전이다.<br />
원소 $x$는 아직 정렬되지 않은 데이터 셋에 있다.</p>

<p><img src="/assets/images/Insertionsort-before.png" alt="alt" width="300px" height="100px" /></p>

<p>정렬이 수행되고 나서는 아래 그림처럼 된다.<br />
원소 $x$는 $&lt;=x$ 보다는 오른쪽 $&gt;x$ 보다는 왼쪽에 있어, 부분 정렬 결과에 속하게 된다.</p>

<p><img src="/assets/images/Insertionsort-after.png" alt="alt" width="300px" height="100px" /></p>

<hr />

<p>다음은 삽입 정렬의 <strong>애니메이션</strong>이다.</p>

<p><img src="/assets/images/Insertion-sort-example.gif" alt="alt" width="450px" height="300px" class="align-center" /></p>

<h2 id="예제">예제</h2>

<p>다음 예제를 보고 알고리즘을 이해해 보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>다음과 같은 리스트가 있다고 하자.  

List = [64 25 12 22 11] - index: 0...4

List = [정렬 완료 | 미정렬]

1 pass: 1번 인덱스 위치의 원소를 선택하여 
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [25 64 | 12 22 11]

2 pass: 2번 인덱스 위치의 원소를 선택하여
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [12 25 64 | 22 11]

3 pass: 3번 인덱스 위치의 원소를 선택하여
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [12 22 25 64 | 11]

4 pass: 4번 인덱스 위치의 원소를 선택하여 
        앞의 원소들과 비교하여 적절한 위치에 삽입한다.

List = [11 12 22 25 64 | ]

n-1번의 pass로 리스트의 정렬이 완료되었다.

List = [11 12 22 25 64]
</code></pre></div></div>

<h2 id="구현">구현</h2>

<p>다음은 삽입 정렬의 의사 코드이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="err">←</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">j</span> <span class="err">←</span> <span class="n">i</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">swap</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">j</span> <span class="err">←</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">end</span> <span class="k">while</span>
    <span class="n">i</span> <span class="err">←</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">end</span> <span class="k">while</span>
</code></pre></div></div>
<hr />
<p>다음은 선택 정렬을 C++로 구현한 코드이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;  
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>  
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>  
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span><span class="n">temp</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">23</span><span class="p">};</span>   
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">printing sorted elements...</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  
    <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>   
    <span class="p">{</span>  
        <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>  
        <span class="n">j</span><span class="o">=</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>  
        <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>  
        <span class="p">{</span>  
            <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>   
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>  
        <span class="p">}</span>  
        <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  
    <span class="p">}</span>  
<span class="p">}</span>  

<span class="cm">/*
Output:
Printing sorted elements . . . 
7
9
10
12
23
23
34
44
78 
101 
*/</span>
</code></pre></div></div>

<p>다음은 선택 정렬을 java로 구현한 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InsertionSort</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">101</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="mi">44</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">78</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">23</span><span class="o">};</span>  
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>   
        <span class="o">{</span>  
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>  
            <span class="kt">int</span> <span class="n">j</span><span class="o">=</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>  
            <span class="k">while</span><span class="o">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">])</span>  
            <span class="o">{</span>  
                <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>   
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>  
            <span class="o">}</span>  
            <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>  
        <span class="o">}</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"printing sorted elements ..."</span><span class="o">);</span>  
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>  
        <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>  
        <span class="o">}</span>  
    <span class="o">}</span>
<span class="o">}</span> 

<span class="cm">/*
Output:
Printing sorted elements . . . 
7
9
10
12
23
23
34
44
78 
101 
*/</span>
</code></pre></div></div>

<h2 id="시간복잡도--공간복잡도">시간복잡도 &amp; 공간복잡도</h2>

<p><strong>시간복잡도 분석</strong></p>

<p>최악 기준 $1$…$n-1$개의 원소를 매 패스마다 비교한다. 
n개의 원소가 있다면 $n-1$의 패스를 가진다.</p>

<script type="math/tex; mode=display">1 + 2 +...+ (n-1) = {\frac {1}{2}}n(n-1)={\frac {1}{2}}(n^{2}-n)</script>

<p>비교의 측면에서 볼 때, 복잡도는 $O(n^2)$이다.</p>

<p>교환(Swap)도 위와 동일하다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>**Insertion sort**

Class	            정렬 알고리즘

Data structure	    배열

Worst-case          О(n^2) 비교
performance         О(n^2) 교환

Best-case           О(n^2) 비교
performance         О(n^2) 교환

Average             О(n^2) 비교
performance         О(n^2) 교환

Worst-case          O(n) 총 공간
space complexity    O(1) 추가 공간
</code></pre></div></div>

<h2 id="references">References</h2>

<p><a href="https://en.wikipedia.org/wiki/Insertion_sort">Insertion sort - wikipedia</a><br />
<a href="https://www.javatpoint.com/insertion-sort">Insertion sort - javatpoint</a></p>
:ET