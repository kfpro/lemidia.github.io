var store = [{
        "title": "너비우선탐색(Breath First Search, BFS)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Spanning Tree"],
        "url": "http://localhost:4000/algorithm/BFS/",
        "teaser":null},{
        "title": "깊이우선탐색(Depth First Search, DFS)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Search Algorithm"],
        "url": "http://localhost:4000/algorithm/DFS/",
        "teaser":null},{
        "title": "다익스트라 알고리즘(Dijkstra Algorithm)- 예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Shortest Path"],
        "url": "http://localhost:4000/algorithm/Dijkstra/",
        "teaser":null},{
        "title": "힙(Heap)-예정 포스트",
        "excerpt":" ","categories": ["Data Structure"],
        "tags": ["Array"],
        "url": "http://localhost:4000/data%20structure/Heap/",
        "teaser":null},{
        "title": "SPFS(Shortest Path Faster Algorithm)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Spanning Tree"],
        "url": "http://localhost:4000/algorithm/SPFS/",
        "teaser":null},{
        "title": "이분 탐색(Binary Search)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Search Algorithm"],
        "url": "http://localhost:4000/algorithm/binary-search/",
        "teaser":null},{
        "title": "카운팅 소트(counting sort)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Sort","Array"],
        "url": "http://localhost:4000/algorithm/counting-sort/",
        "teaser":null},{
        "title": "플로이드 와샬 알고리즘(Floyd Warshall Algorithm)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Shortest Path"],
        "url": "http://localhost:4000/algorithm/floyd-warshall/",
        "teaser":null},{
        "title": "그리디 알고리즘(Greedy Algorithm)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Spanning Tree"],
        "url": "http://localhost:4000/algorithm/greedy/",
        "teaser":null},{
        "title": "크루스칼 알고리즘(Kruskal's Algorithm)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Graph","Union Find","Spanning Tree"],
        "url": "http://localhost:4000/algorithm/kruskal/",
        "teaser":null},{
        "title": "퀵소트(Quick Sort)-예정 포스트",
        "excerpt":" ","categories": ["Algorithm"],
        "tags": ["Sort","Array","Mathematics"],
        "url": "http://localhost:4000/algorithm/quick-sort/",
        "teaser":null},{
        "title": "선택 정렬(Selection Sort)",
        "excerpt":"선택 정렬   선택 정렬은 비교기반 제자리 정렬 알고리즘이다.  복잡도는 $O(n^2)$이므로 큰 리스트에는 비효율적이며, 유사한 삽입 정렬보다 성능이 더 떨어지는 것이 일반적이다. 선택 정렬은 단순함이 특징이며 특정한 상황(메모리가 제한적인 경우)에서는 더 복잡한 알고리즘보다 성능상 우위가 있다.   비교기반과 제자리 정렬 이란?   비교기반: 원소들을 정렬할 때 원소들의 순서에만 의존하는 것을 의미.  비교하는 원소들이 숫자거나, 문자열이거나, 심지어는 복잡한 객체에 대해서도 순서가 결정되어 있다면 적용할 수 있다.  제자리 정렬: 원소들의 개수에 비해서 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘들을 의미.  예를 들어 삽입 정렬은 이미 주어진 원소들을 옮긴 뒤 적절한 위치에 원소를 삽입하는 연산을 반복하는데, 이 과정에서 원소들을 담는 공간 외에 추가로 사용될 수 있는 공간은 옮겨지는 원소가 저장되는 공간과 루프 변수 정도에 불과하다.   알고리즘   다음은 선택 정렬의 알고리즘이다. (오름차순)      먼저, 정렬될 리스트에서 가장 최소값을 찾는다.   1번에서 찾은 값을 정렬될 리스트의 맨 처음 위치한 값과 바꾼다. (1 pass)   맨 처음 위치를 제외한 나머지 리스트의 원소들에 대해서 이를 반복한다.   1 pass: 정렬이 되지않은 리스트에서 최소값을 선택해, 리스트의 적절한 위치에 넣는다.   이처럼, n개의 원소를 가진 리스트는 선택 정렬로 n-1번의 패스를 거쳐 정렬이 된다.   비교하는 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 리스트를 위와 같은 방법으로 정렬하는 데에는 $O(n^2)$ 만큼의 시간이 걸린다.     다음은 선택 정렬의 애니메이션이다.      예제   다음 예제를 보고 알고리즘을 이해해 보자.   다음과 같은 리스트가 있다고 하자.    List = [64 25 12 22 11] - index: 0...4  List = [정렬 완료 | 미정렬]  1 pass: List[0...4]를 순회하여 최소값인 11을 찾고           이를 0번째 인덱스 위치의 64와 스왑한다.  List = [11 | 25 12 22 64]  2 pass: List[1...4]를 순회하여 최소값인 12을 찾고         이를 1번째 인덱스 위치의 25와 스왑한다.  List = [11 12 | 25 22 64]  3 pass: List[2...4]를 순회하여 최소값인 22을 찾고           이를 2번째 인덱스 위치의 25와 스왑한다.  List = [11 12 22 | 25 64]  4 pass: List[3...4]를 순회하여 최소값인 25을 찾고   이를 3번째 인덱스 위치의 25와 스왑한다.  List = [11 12 22 25 | 64]  n-1번의 pass로 리스트의 정렬이 완료되었다.   구현   다음은 선택 정렬을 C로 구현한 코드이다.   /* a[0] to a[aLength-1] is the array to sort */ int i,j; int aLength; // initialise to a's length  /* advance the position through the entire array */ /*   (could do i &lt; aLength-1 because single element is also min element) */ for (i = 0; i &lt; aLength-1; i++) {     /* find the min element in the unsorted a[i .. aLength-1] */      /* assume the min is the first element */     int jMin = i;     /* test against elements after i to find the smallest */     for (j = i+1; j &lt; aLength; j++)     {         /* if this element is less, then it is the new minimum */         if (a[j] &lt; a[jMin])         {             /* found new minimum; remember its index */             jMin = j;         }     }      if (jMin != i)      {         swap(a[i], a[jMin]);     } }   다음은 선택 정렬을 자바로 구현한 코드이다.   void selectionSort(int[] list) {     int indexMin, temp;      for (int i = 0; i &lt; list.length - 1; i++) {         // Lowest position         indexMin = i;         for (int j = i + 1; j &lt; list.length; j++) {             if (list[j] &lt; list[indexMin]) {                 indexMin = j;             }         }         // Swap         temp = list[indexMin];         list[indexMin] = list[i];         list[i] = temp;     } }   시간복잡도 &amp; 공간복잡도   시간복잡도 분석   $n$ $(n-1…1)$개의 원소를 매 패스마다 스캔하여 적절한 위치와 스왑한다.  n개의 원소가 있다면 $n-1$의 패스를 가진다.     등차수열에 의해,     비교의 측면에서 볼 때, 복잡도는 $O(n^2)$이다.   교환은 매 패스마다 한 번씩 일어난다. 즉, $n-1$번 복잡도는 $O(n)$  (마지막 원소는 이미 정렬되어 있다.)  **Selection sort**  Class\t            정렬 알고리즘  Data structure\t    배열  Worst-case          О(n^2) 비교 performance         О(n) 교환  Best-case           О(n^2) 비교 performance         О(n) 교환  Average             О(n^2) 비교 performance         О(n) 교환  Worst-case          O(1) 추가 공간 space complexity\t   References   Selection sort  Selection sort - GIF  ","categories": ["Algorithm"],
        "tags": ["Sort","Array"],
        "url": "http://localhost:4000/algorithm/selection-sort/",
        "teaser":null},{
        "title": "최소 스패닝 트리(Spanning Tree)-예정 포스트",
        "excerpt":" ","categories": ["Data Structure"],
        "tags": ["Spanning Tree","Tree"],
        "url": "http://localhost:4000/data%20structure/spanning-tree/",
        "teaser":null},{
        "title": "연결 리스트(Linked List)",
        "excerpt":"Linked List  배열과 같이 선형 자료구조 이다.  원소들이 메모리 공간상에 연속적으로 저장 되어있지 않고, 그림과 같이 각 원소들이 포인터로 링크되어 있는 자료 구조이다.   하나의 원소를 노드라고 표현하고, 데이터를 저장하는 Data 필드와 그 다음 노드를 가리키는 Next필드로 구성되어 있다.   추가적으로 연결 리스트의 맨 처음 노드를 가리키는 헤드라는 포인터를 두고 있다.   그림을 참고하자.      배열과 비교해 연결 리스트가 가지는 장점   베열은 유사한 타입의 선형 데이터를 저장하는데 사용될 수 있다.  하지만 배열은 다음과 같은 제한을 가진다.      배열 크기가 고정되어 있다.  그래서 우리는 배열의 상한크기를 미리 알고 있어야 한다.  또한, 일반적으로, 할당된 메모리는 사용량에 관계없이 상한과 동일하다.   배열에 원소를 삽입하는 연산은 연결 리스트와 비교해 다소 비용이 많이든다.  원소를 저장할 공간이 만들어져야 하며, 특정 위치에 값을 삽입한다면 다른 원소를 한칸 씩 쉬프트 해야할 수도 있다.   연결 리스트가 배열과 비교해 가지는 장점      동적 크기  연결 리스트의 크기는 고정되어 있지 않고, 프로그램 실행중에 동적으로 변할 수 있다.  운영체제가 프로그램상의 메모리 공간을 허용하는 한 연결 리스트의 크기를 신경 쓸 필요가 없다.   원소의 삽입 및 삭제가 수월하다.  배열과 비교해 연결 리스트의 삽입 삭제는 노드들 간에 포인터만 설정해주면 된다.  새로운 원소를 위해 다른 원소를 위치를 쉬프트 한다든지의 수고를 할 필요가 없다.   배열과 비교해 연결 리스트가 가지는 단점           임의 접근이 되지 않는다.  배열은 각 원소를 index 번호로 바로 접근할 수 있는 반면(Random access), 연결 리스트에서는 처음 노드부터 순차적으로 탐색해야 한다.            포인터로 인한 메모리상 추가적인 공간이 필요하다.  배열과 달리 연결 리스트는 다른 노드를 가리키는 포인터(Next)공간을 추가로 요구한다.            캐시 친화적이지 않다.  배열 요소는 연속된 메모리 공간상에 위치하므로 참조 지역성이 좋은 반면, 연결 리스트는 요소들이 링크되어 있고 메모리 상에 흩어져 존재하므로 참조 지역성이 없다.       Representation   연결 리스트는 첫번째 노드를 가리키는 헤드를 가지고 있다.  연결 리스트에 노드가 없다면 헤드는 NULL이다.      노드는 두개의 부분으로 구성되어 있다.      Data - 데이터를 저장하는 필드(Integer, Double, String, Object …)   Next(Pointer Or Reference) - 다음 노드를 참조하는 필드   다음은 자바로 구현한 연결 리스트 클래스이다.   class LinkedList {      Node head; // head of the list         /* Linked list Node*/     static class Node {          int data;          Node next;          Node(int d)          {              data = d;              next = null;          } // Constructor      }  }   연결 리스트는 하나의 클래스로 표현되고 있고, 노드는 그 안의 분리된 클래스로 표현되고 있다.   연결 리스트 클래스의 헤드는 노드를 참조하므로 노드 클래스 타입으로 선언 되어있다.   노드 클래스는 데이터를 저장하는 data필드와 다음 노드를 참조할 수 있는 next필드를 가지고 있다. 또한 생성자를 가지고 있는데, 이는 노드가 생성될 때 데이터를 d로 초기화하고, 포인터를 null로 초기화하는 역할을 한다.     위 클래스를 이용하여 노드 3개를 가진 연결리스트를 자바로 구현해 보자.   // A simple Java program to introduce a linked list  class LinkedList {      Node head; // head of list         /* Linked list Node.  This inner class is made static so that         main() can access it */     static class Node {          int data;          Node next;          Node(int d)          {              data = d;              next = null;          } // Constructor      }         /* method to create a simple linked list with 3 nodes*/     public static void main(String[] args)      {          /* 빈 연결 리스트 생성 */         LinkedList llist = new LinkedList();             llist.head = new Node(1);          Node second = new Node(2);          Node third = new Node(3);             /* 3개의 노드가 메모리상에 할당된다.            head와 second, third가 각 노드를 참조한다.              llist.head        second              third               |                |                  |               |                |                  |           +----+------+     +----+------+     +----+------+           | 1  | null |     | 2  | null |     |  3 | null |           +----+------+     +----+------+     +----+------+ */            llist.head.next = second; // 첫번째 노드와 두번째 노드를 연결한다.            /*  첫번째 노드의 next가 두번째 노드를 참조한다.             llist.head        second              third              |                |                  |              |                |                  |          +----+------+     +----+------+     +----+------+          | 1  |  o--------&gt;| 2  | null |     |  3 | null |          +----+------+     +----+------+     +----+------+ */            second.next = third; // 세번째 노드와 두번째 노드를 연결한다.            /*  두번째 노드의 next가 세번째 노드를 참조한다.             llist.head        second              third              |                |                  |              |                |                  |          +----+------+     +----+------+     +----+------+          | 1  |  o--------&gt;| 2  |  o--------&gt;|  3 | null |          +----+------+     +----+------+     +----+------+ */     }  }    Inserting a node   연결 리스트에 노드를 추가 해보자.   노드를 추가하는 데에는 3 가지 케이스가 있다.      연결 리스트 맨 앞에 추가   특정 노드 뒤에 추가   연결 리스트 맨 뒤에 추가   연결 리스트 맨 앞에 추가      추가할 노드를 할당한다.   노드에 데이터를 넣는다.   추가할 노드의 next 포인터가 첫번째 노드를 참조하게 한다.   헤드가 추가한 노드를 참조하게 함으로써 처음 노드임을 가리킨다.      다음은 위의 연산을 구현한 자바 메소드이다.   /* This function is in LinkedList class. Inserts a     new Node at front of the list. */ public void push(int new_data)  {      /* 1 &amp; 2: Allocate the Node &amp;                Put in the data*/     Node new_node = new Node(new_data);         /* 3. Make next of new Node as head */     new_node.next = head;         /* 4. Move the head to point to new Node */     head = new_node;  }    이 연산의 시간복잡도는 O(1)이 된다.   특정 노드 뒤에 추가      특정 노드가 null인지 확인한다.  null이면 아무런 작업이 수행되지 않는다.   추가할 노드를 할당한다.   추가할 노드에 데이터를 넣는다.   추가할 노드가 특정노드가 참조하는 다음 노드를 참조하게 한다.   특정 노드가 추가할 노드를 참조하게 한다.      다음은 위의 연산을 구현한 자바 메소드이다.   /* This function is in LinkedList class.     Inserts a new node after the given prev_node. */ public void insertAfter(Node prev_node, int new_data)  {      /* 1. Check if the given Node is null */     if (prev_node == null)      {          System.out.println(\"The given previous node cannot be null\");          return;      }         /* 2. Allocate the Node &amp;         3. Put in the data*/     Node new_node = new Node(new_data);         /* 4. Make next of new Node as next of prev_node */     new_node.next = prev_node.next;         /* 5. make next of prev_node as new_node */     prev_node.next = new_node;  }    이 연산의 시간복잡도는 O(1)이 된다.   연결 리스트 맨 뒤에 추가      추가할 노드를 할당한다.   추가할 노드에 데이터를 넣는다.   연결 리스트가 null이면, 헤드가 추가할 노드를 참조하게 함으로써 연산을 끝낸다.   그렇지 않다면, 처음 노드부터 탐색을 시작하여 마지막 노드를 찾는다.   마지막 노드가 추가할 노드를 참조하게 한다.      다음은 위의 연산을 구현한 자바 메소드이다.    // Appends a new node at the end.  public void append(int new_data)  {      /* 1. Allocate the Node &amp;         2. Put in the data */     Node new_node = new Node(new_data);         /* 3. If the Linked List is empty, then make the             new node as head */     if (head == null)      {          head = new Node(new_data);          return;      }      /* 4. Else traverse till the last node */     Node last = head;       while (last.next != null)          last = last.next;         /* 5. Change the next of last node */     last.next = new_node;      return;  }    이 연산의 시간복잡도는 탐색으로 인하여 O(n)이 된다.  연결 리스트의 끝 노드의 정보를 가지고 있는 tail 포인터를 둔다면, 이 연산의 시간복잡도는 O(1)이 된다.   다음은 위 연산을 포한한 예제 자바 코드이다.   // A complete working Java program to demonstrate all insertion methods  // on linked list  class LinkedList  {      Node head;  // head of list         /* Linked list Node*/     class Node      {          int data;          Node next;          Node(int d) {data = d; next = null; }      }         /* Inserts a new Node at front of the list. */     public void push(int new_data)      {          /* 1 &amp; 2: Allocate the Node &amp;                    Put in the data*/         Node new_node = new Node(new_data);             /* 3. Make next of new Node as head */         new_node.next = head;             /* 4. Move the head to point to new Node */         head = new_node;      }         /* Inserts a new node after the given prev_node. */     public void insertAfter(Node prev_node, int new_data)      {          /* 1. Check if the given Node is null */         if (prev_node == null)          {              System.out.println(\"The given previous node cannot be null\");              return;          }             /* 2 &amp; 3: Allocate the Node &amp;                    Put in the data*/         Node new_node = new Node(new_data);             /* 4. Make next of new Node as next of prev_node */         new_node.next = prev_node.next;             /* 5. make next of prev_node as new_node */         prev_node.next = new_node;      }            /* Appends a new node at the end.  This method is          defined inside LinkedList class shown above */     public void append(int new_data)      {          /* 1. Allocate the Node &amp;             2. Put in the data */         Node new_node = new Node(new_data);             /* 3. If the Linked List is empty, then make the                new node as head */         if (head == null)          {              head = new Node(new_data);              return;          }             /* 4. Else traverse till the last node */         Node last = head;           while (last.next != null)              last = last.next;             /* 5. Change the next of last node */         last.next = new_node;          return;      }         /* This function prints contents of linked list starting from          the given node */     public void printList()      {          Node tnode = head;          while (tnode != null)          {              System.out.print(tnode.data+\" \");              tnode = tnode.next;          }      }         /* Driver program to test above functions. Ideally this function         should be in a separate user class.  It is kept here to keep         code compact */     public static void main(String[] args)      {          /* Start with the empty list */         LinkedList llist = new LinkedList();             // Insert 6.  So linked list becomes 6-&gt;NUllist          llist.append(6);             // Insert 7 at the beginning. So linked list becomes          // 7-&gt;6-&gt;NUllist          llist.push(7);             // Insert 1 at the beginning. So linked list becomes          // 1-&gt;7-&gt;6-&gt;NUllist          llist.push(1);             // Insert 4 at the end. So linked list becomes          // 1-&gt;7-&gt;6-&gt;4-&gt;NUllist          llist.append(4);             // Insert 8, after 7. So linked list becomes          // 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NUllist          llist.insertAfter(llist.head.next, 8);             System.out.println(\"\\nCreated Linked list is: \");          llist.printList();      }  }  // This code is contributed by Rajat Mishra    Output: Created Linked list is:  1  7  8  6  4   Deleting a node   이번에는 연결 리스트에서 특정 키 값을 갖고 있는 노드를 삭제 해보자.      삭제될 노드를 참조할 temp 포인터와 그 이전 노드를 참조하는 prev 포인터를 둔다.   temp는 헤드를 참조하게 함으로써 처음 노드를 참조하게 한다.   만약 삭제될 노드가 처음 노드라면, 헤드가 temp 다음 노드를 참조하게 하고 연산을 끝낸다.   그렇지 않다면, 삭제할 키 값을 가지고 있는 노드를 탐색한다.   탐색함에 따라 삭제될 노드와 그 이전 노드 정보를 가지고 있는 temp, prev 포인터들을 갱신한다.   temp가 null이거나 삭제될 키 값을 가진 노드를 찾으면 반복문을 빠져나온다.   temp가 null이면 원하는 키값을 가진 노드를 찾지 못한 것이므로 아무런 작업도 하지 않고 연산을 끝낸다.   그렇지 않다면 찾은 것이므로, prev 포인터가 temp.next 참조하게 함으로써 작업을 끝낸다.      다음은 위의 연산을 구현한 자바 메소드이다.    /* Given a key, deletes the first occurrence of key in linked list */     void deleteNode(int key)      {          // 1 &amp; 2. Store head node to temp, prev         Node temp = head, prev = null;             // 3. If head node itself holds the key to be deleted          if (temp != null &amp;&amp; temp.data == key)          {              head = temp.next; // Changed head              return;          }             // 4. Search for the key to be deleted, keep track of the          // previous node as we need to change temp.next          while (temp != null &amp;&amp; temp.data != key) // 6.         {              // 5. keep track of the previous node             //    as we need to change temp.next              prev = temp;                     temp = temp.next;          }                 // 7. If key was not present in linked list          if (temp == null) return;             // 8. Unlink the node from linked list          prev.next = temp.next;      }     이 연산의 시간복잡도는 O(n)이 된다.  순수 삭제연산은 O(1)이지만, 삭제될 키 값을 찾아 탐색하는 연산이 추가되었으므로 O(n)이 된다.   특정 키 값의 노드 찾기   연결 리스트에서 특정 키 값 x를 가진 노드를 찾아보자.   search 메소드는 키 값 x를 가진 노드가 존재하면 true, 존재하지 않으면 false를 리턴한다.      리스트를 순회할 current를 헤드로 초기화한다.   current가 null 아닐 때 까지 반복한다.  null이면 while 빠져나와 false 리턴하고 연산을 끝낸다.   current가 참조하는 노드의 데이터가 x라면 true 리턴하고 연산을 끝낸다.   그렇지 않다면 다음 노드를 참조하고 2번으로 다시 간다.   다음은 위의 연산을 구현한 자바 메소드이다.   //Checks whether the value x is present in linked list      public boolean search(Node head, int x)      {          Node current = head;    // 1 포인터 초기화         while (current != null) // 2. current가 null 아닐 때 까지 반복한다         {              if (current.data == x)                  return true;    //3. 찾았다             current = current.next; // 4. 다음 노드를 참조한다         }          return false;    // 데이터를 찾지 못하였다     }    다음은 위 연산을 포한한 예제 자바 코드이다.   // Iterative Java program to search an element  // in linked list     //Node class  class Node  {      int data;      Node next;      Node(int d)      {          data = d;          next = null;      }  }     //Linked list class  class LinkedList  {      Node head;    //Head of list         //Inserts a new node at the front of the list      public void push(int new_data)      {          //Allocate new node and putting data          Node new_node = new Node(new_data);             //Make next of new node as head          new_node.next = head;             //Move the head to point to new Node          head = new_node;      }         //Checks whether the value x is present in linked list      public boolean search(Node head, int x)      {          Node current = head;    //Initialize current          while (current != null)          {              if (current.data == x)                  return true;    //data found              current = current.next;          }          return false;    //data not found      }         //Driver function to test the above functions      public static void main(String args[])      {             //Start with the empty list          LinkedList llist = new LinkedList();             /*Use push() to construct below list          14-&gt;21-&gt;11-&gt;30-&gt;10  */         llist.push(10);          llist.push(30);          llist.push(11);          llist.push(21);          llist.push(14);             if (llist.search(llist.head, 21))              System.out.println(\"Yes\");          else             System.out.println(\"No\");      }  }  // This code is contributed by Pratik Agarwal    Output: Yes  연결 리스트 연산들의 시간복잡도  시간복잡도 - 최악 기준        접근     검색      삽입     삭제\t O(n)    O(n)\t O(1)\t O(1)\t    References  GeeksforGeeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Linked List"],
        "url": "http://localhost:4000/data%20structure/LinkedList/",
        "teaser":null},{
        "title": "스택(Stack)",
        "excerpt":"스택(Stack)  스택은 원소의 특정한 순서를 유지하고 특정 연산을 가지고 있는 선형 자료구조이다.   스택은 후입선출의 선형 자료 구조로서, 한쪽 끝에서만 삽입 및 삭제가 수행된다.  나중에 들어간 원소가 먼저 들어온 원소보다 먼저 나간다 하여 후입선출이라 불리게 된다.   스택은 또한 Top이라 불리는 포인터를 가지고 있는데 이는, 스택의 맨 위의 원소를 가리킨다.(그림상)      스택의 기본 연산   스택이 가지고 있는 연산들을 보자.   Push   스택에 원소를 삽입한다.  스택이 Full이라면 Overflow 에러가 난다.      Notice: 새로운 원소가 삽입됨에 따라 Top이 10을 가리키고 있다.   Pop - 스택에서 원소를 삭제한다.   스택에서 원소를 삭제한다.  스택이 빈 공간이면, Underflow 에러가 난다.      Notice: 기존 원소가 삭제됨에 따라 Top이 93을 가리키고 있다.   Peek  스택에서 Top 가리키고 있는 원소를 반환한다.   Notice: 원소가 삽입, 삭제 되는 것이 아닌 원소 반환이므로 Top의 위치는 변화가 없다.      isEmpty  스택이 빈 공간이라면 true, 아니라면 false를 반환한다.   스택의 응용   스택은 많은 곳에서 응용되어 쓰인다.      괄호의 균형성 검사. ex) (()) 짝이 맞는지   웹브라우저의 앞으로 가기 또는 뒤로 가기   그래프 알고리즘 중에서 위상정렬이나 강한연결요소   대표적 백트래킹 문제 - N-Queen, Knight tour, rat in a maze, sudoku   스택을 이용한 여러 알고리즘 문제 - 하노이 탑, 트리순회, 히스토그램 면적 등   중위식 표기법의 후위식 표기법으로의 변환   구현   스택을 구현하는 데에는 크게 두 가지 방법이 있다.      배열을 이용   연결 리스트를 이용   먼저 배열을 이용한 스택 구현을 보자.   배열을 이용한 스택 구현   스택 클래스의 프로퍼티와 생성자   스택의 최대 크기를 결정하는 MAX 상수, top 포인터, 원소를 담을 배열을 선언한다.  스택이 생성되면 top을 -1로 초기화할 생성자를 선언한다.  class Stack {      static final int MAX = 1000;      int top;      int a[] = new int[MAX]; // Maximum size of Stack       public Stack() // Constructor of Stack Class     {          top = -1;      }  }   스택 클래스의 메서드 - push   스택에 원소를 삽입하는 메서드이다.   top이 배열의 끝(MAX-1)을 가리키고 있으면 스택은 다 차서 더 이상 원소 삽입이 안되므로 에러 메세지를 출력하고 false를 리턴한다.   그렇지 않다면 top을 한 칸 올리고 그 자리에 원소를 삽입한다.   boolean push(int x)  {      if (top &gt;= (MAX - 1)) {          System.out.println(\"Stack Overflow\");          return false;      }      else {          a[++top] = x;          System.out.println(x + \" pushed into stack\");          return true;      }  }    스택 클래스의 메서드 - pop   스택에서 원소를 삭제하는 메서드이다.   top이 0보다 작으면 스택은 빈 공간이므로 에러 메세지를 출력하고 false를 리턴한다.   그렇지 않다면 top이 가리키는 원소를 리턴하고 top은 한 칸 감소한다.   int pop()  {      if (top &lt; 0) {          System.out.println(\"Stack Underflow\");          return 0;      }      else {          int x = a[top--];          return x;      }  }    스택 클래스의 메서드 - peek   스택의 top이 가리키는 원소를 반환하는 메서드이다.   top이 0보다 작으면 스택은 빈 공간이므로 에러 메세지를 출력하고 false를 리턴한다.   그렇지 않다면 top이 가리키는 원소를 리턴한다.   int peek()  {      if (top &lt; 0) {          System.out.println(\"Stack Underflow\");          return 0;      }      else {          int x = a[top];          return x;      }  }    스택 클래스의 메서드 - isEmpty   스택이 빈 공간인지 확인하는 메서드이다.   top이 0보다 작으면 스택은 빈 공간이므로 true 리턴   그렇지 않다면 원소가 있다는 뜻이므로 false 리턴   int peek()  boolean isEmpty()  {      return (top &lt; 0);  }    전체 코드   다음은 배열을 이용하여 스택을 구현한 전체 코드이다.   /* Java program to implement basic stack  operations */ class Stack {      static final int MAX = 1000;      int top;      int a[] = new int[MAX]; // Maximum size of Stack         boolean isEmpty()      {          return (top &lt; 0);      }      Stack()      {          top = -1;      }         boolean push(int x)      {          if (top &gt;= (MAX - 1)) {              System.out.println(\"Stack Overflow\");              return false;          }          else {              a[++top] = x;              System.out.println(x + \" pushed into stack\");              return true;          }      }         int pop()      {          if (top &lt; 0) {              System.out.println(\"Stack Underflow\");              return 0;          }          else {              int x = a[top--];              return x;          }      }         int peek()      {          if (top &lt; 0) {              System.out.println(\"Stack Underflow\");              return 0;          }          else {              int x = a[top];              return x;          }      }  }     // Driver code  class Main {      public static void main(String args[])      {          Stack s = new Stack();          s.push(10);          s.push(20);          s.push(30);          System.out.println(s.pop() + \" Popped from stack\");      }  }   Output : 10 pushed into stack 20 pushed into stack 30 pushed into stack 30 popped from stack   연결 리스트 이용한 스택 구현   연결 리스트를 이용한 스택 클래스 표현   스택의 top을 표현할 StackNode 타입의 root 레퍼런스 가지고 있다.   또한, 스택 원소 즉, 노드를 표현할 내부 클래스를 가지고 있다.  내부 클래스인 스택 노드 클래스는 데이터를 담을 data 변수, 다음 원소를 가리키는 next 레퍼런스 변수를 가지고 있다.   public class StackAsLinkedList {     StackNode root;       static class StackNode {          int data;          StackNode next;          StackNode(int data) {              this.data = data;          }      }  }   스택 클래스의 메서드 - push   데이터를 받아 노드를 할당한다.   스택이 빈 공간이면 단순히 root가 새로 생성된 노드를 가리키게 한다.   빈 공간이 아니라면 임시 레퍼런스 변수 temp가 root를 가리키게한다.  root는 새로 생성된 노드를 가리키게 하고, 새로 생성된 노드는 temp를 가리키게 한다.   public void push(int data)  {      StackNode newNode = new StackNode(data);       if (root == null) {          root = newNode;      }      else {          StackNode temp = root;          root = newNode;          newNode.next = temp;      }      System.out.println(data + \" pushed to stack\");  }    스택 클래스의 메서드 - pop   스택이 빈 공간이면 에러 메세지를 출력하고 int 최소 값을 반환한다.  (여기서는 Integer.MIN_VALUE는 빈 공간임을 표시하는 수로 쓰였다.)   빈 공간이 아니라면 popped 변수에 값을 담고, root는 다음 변수를 가리키게 한다.  popped을 리턴한다.   public int pop()  {      int popped = Integer.MIN_VALUE;      if (root == null) {          System.out.println(\"Stack is Empty\");      }      else {          popped = root.data;          root = root.next;      }      return popped;  }    스택 클래스의 메서드 - peek   스택이 빈 공간이면 에러 메세지를 출력하고 int 최소 값을 반환한다.  (여기서도 Integer.MIN_VALUE는 빈 공간임을 표시하는 수로 쓰였다.)   빈 공간이 아니라면 root가 가리키는 값을 리턴한다.   public int peek()  {      if (root == null) {          System.out.println(\"Stack is empty\");          return Integer.MIN_VALUE;      }      else {          return root.data;      }  }    스택 클래스의 메서드 - isEmpty   스택이 빈 공간 즉, root가 null이면 true 리턴, 아니라면 false 리턴   public boolean isEmpty()  {      if (root == null) {          return true;      }      else         return false;  }    전체 코드   다음은 연결 리스트를 이용하여 스택을 구현한 전체 코드이다.   public class StackAsLinkedList {         StackNode root;         static class StackNode {          int data;          StackNode next;             StackNode(int data)          {              this.data = data;          }      }         public boolean isEmpty()      {          if (root == null) {              return true;          }          else             return false;      }         public void push(int data)      {          StackNode newNode = new StackNode(data);             if (root == null) {              root = newNode;          }          else {              StackNode temp = root;              root = newNode;              newNode.next = temp;          }          System.out.println(data + \" pushed to stack\");      }         public int pop()      {          int popped = Integer.MIN_VALUE;          if (root == null) {              System.out.println(\"Stack is Empty\");          }          else {              popped = root.data;              root = root.next;          }          return popped;      }         public int peek()      {          if (root == null) {              System.out.println(\"Stack is empty\");              return Integer.MIN_VALUE;          }          else {              return root.data;          }      }         public static void main(String[] args)      {             StackAsLinkedList sll = new StackAsLinkedList();             sll.push(10);          sll.push(20);          sll.push(30);             System.out.println(sll.pop() + \" popped from stack\");             System.out.println(\"Top element is \" + sll.peek());      }  }   Output : 10 pushed to stack 20 pushed to stack 30 pushed to stack 30 popped from stack Top element is 20   스택 연산들의 시간복잡도  시간복잡도 - 최악 기준        push    pop      peek    isEmpty\t O(1)    O(1)\t O(1)\t O(1)\t    References  GeeksforGeeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Linked List","Array","Stack"],
        "url": "http://localhost:4000/data%20structure/Stack/",
        "teaser":null},{
        "title": "선형구조와 탐색(Linear Structure and Search)",
        "excerpt":"선형구조의 탐색   선형구조란 자료의 순서를 유일하게 결정할 수 있는 형태의 구조를 말한다. $i$번째 자료 를 탐색한 다음, $i+1$번째로 탐색해야할 자료가 유일한 형태를 의미한다. 2차원, 3차원 구조라도 순서가 일정하게 정해져 있으면 이는 선형이라고 할 수 있다.   선형구조는 주로 배열과 리스트의 형태로 저장된다. 일반적으로 1차원 배열에 자료를 저장하는 1차원 선형구조와 2차원 이상의 배열에 자료가 저장이 되어있는 다차원 선형구조로 나눌 수 있다.   선형구조의 탐색은 선형구조로 저장된 자료들 중에서 원하는 것을 찾는 작업을 말한다. 선형구조를 탐색하는 방법은 기본적으로 순차탐색과 이분탐색이 있고, 이들을 적절히 응용한 탐색법도 만들어 사용할 수 있다. 이 단원에서는 순차탐색과 이분탐색을 익히고 이를 통하여 간단한 문제를 해결하는 실습을 한다.   순차탐색   순차탐색은 자료의 특성에 관계없이 사용할 수 있는 일반적인 방법으로 전체탐색기법의 한 방법이다. 첫 번째 원소로부터 시작하여 한 원소씩 차례로 다음 원소를 탐색해 나가는 방법으로 자료가 $n$개 있을 때의 계산량은 $O(n)$이다.   탐색 순서를 그림으로 나타내면 다음과 같다.      다음은 선형탐색을 구현한 소스코드이다.  public class LinearSearch {     public static boolean linearSearch(int S[], int k){         for (int i = 0; i &lt; S.length; i++) {             if (S[i] == k)                 return true;         }         return false;     }      public static void main(String[] args) {         int S[] = {5, 2, 6, 2, 1, 8};         int k = 4;         System.out.print(linearSearch(S, k));     } }   이분탐색   이분탐색은 배열에서 중간 원소를 선택하여 찾는 값과 비교하고 중간 원소의 값이 찾는 값보다 작다면 중간 원소를 기준으로 오른쪽을 탐색, 중간 원소의 값이 찾는 값보다 크다면 중간 원소를 기준으로 왼쪽을 탐색하는 기법이다. 이 알고리즘은 오름차순이나 내림차순으로 정렬된 선형구조에서 원하는 원소를 찾는 것으로 계산량은 $O(log_2n)$이다.      이분탐색의 탐색순서(원은 처음 접근하는 원소이고, 사각형은 찾은 곳의 값이 찾으려는 값보다 작으면 찾는 위치, 둥근 사각형은 그 값의 반대조건일 경우에 탐색하는 위치이다. 조건의 결과에 따라 왼쪽 또는 오른쪽 중 하나를 탐색하게 된다.)   다음은 이분탐색을 구현한 C++ 소스코드이다.  $S$에 $n$개의 원소를 입력받고, 그 중에 $k$가 있는지를 찾는 알고리즘이다.   // 이분탐색 - 반복 #include &lt;stdio.h&gt; int S[100], n, k; int find(int s, int e) {   while(s&lt;=e) {  // s가 e보다 작거나 같을 때 까지     int m=(s+e)/2; // 중간 원소     if(S[m]==k) return m; // 찾았다      // 탐색한 원소가 찾고자 하는 원소 보다 크다     //탐색한 원소의 왼쪽 배열 탐색     if(S[m]&gt;k) e=m‐1;      // 탐색한 원소가 찾고자 하는 원소 보다 작다     //탐색한 원소의 오른쪽 배열 탐색     else s=m+1;   }   return ‐1; // 원하는 원소를 찾지 못했다. } int main() {   scanf(\"%d%d\", &amp;n, &amp;k);   for(int i=0; i&lt;n; i++ )     scanf(\"%d\", &amp;S[i]);    printf(\"%d\\n\", find(0, n‐1));   return 0; }   다음은 재귀로 이분탐색을 구현한 java 소스코드이다.    // 이분탐색 - 재귀 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; import java.util.StringTokenizer;  public class BinarySearchRecur {     private static int S[] = new int[100];     private static int n, k; // 배열 크기, 찾고자 하는 원소      public static int find(int s, int e){         if (s &gt; e) // 원하는 원소를 찾지 못했다             return -1;         int m = (s+e)/2; // 중간 원소         if (S[m] == k) // 찾았다             return m;         else if (S[m] &lt; k) // 탐색한 원소가 찾고자 하는 원소 보다 작다             return find(m+1, e); //탐색한 원소의 오른쪽 배열 탐색         else               // 탐색한 원소가 찾고자 하는 원소 보다 크다             return find(s, m-1); //탐색한 원소의 왼쪽 배열 탐색     }      public static void main(String[] args) throws IOException {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));         StringTokenizer st = new StringTokenizer(br.readLine()); // n, k         n = Integer.parseInt(st.nextToken());         k = Integer.parseInt(st.nextToken());         st = new StringTokenizer(br.readLine()); // S array         Arrays.sort(S);         for (int i = 0; i &lt; n; i++) {             S[i] = Integer.parseInt(st.nextToken());         }         System.out.print(find(0, n-1)); // index 반환     } }  /*  Test Case ----------- input 5 19 3 4 2 19 4  output 3 ----------- input 5 10 3 4 2 19 4  output -1  */    기본적인 탐색방법을 익힐 수 있는 다음 문제들을 해결해보자.   최댓값   9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고  그 값이 몇 번째 수 인지를 구하는 프로그램을 작성하시오.  예를 들어, 서로 다른 9개의 자연수가 각각 3, 29, 38, 12, 57, 74, 40, 85, 61 라면,   이 중 최댓값은 85이고, 이 값은 8번째 수이다.  ----------------------------------------  입력 첫째 줄부터 아홉째 줄까지 한 줄에 하나의 자연수가 주어진다.  주어지는 자연수 는 100보다 작다.  출력 첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이  몇 번째 수인지를 출력한다.  입력 예      출력 예 3          85 29         8 38 12 57 74  40  85  61   이 문제는 자료를 1차원 배열에 저장한 후 반복문을 이용하여 전체탐색법을 구현하면 쉽게 구할 수 있다. 전체탐색을 하더라도 탐색해야할 자료의 수가 9개뿐이므로 충분히 빠른 시간 내에 해를 구할 수 있는 기본적인 문제이다.   따라서 반복문을 구현하는 연습을 할 수 있는 문제로 이 문제를 해결하는 방법이 다른 문제들을 해결하는 도구로 많이 활용될 수 있으므로 꼭 익혀둘 수 있도록 한다.   일단 먼저 문제해결 아이디어를 생각하자. 최종적으로 출력할 해를 변수 ans로 두고, 최댓값의 인덱스를 저장할 변수를 index로 설정한다.   먼저 모든 자료를 탐색하기 전에 ans를 모든 원소들 보다 작은 값으로 설정한다. 이 문제에서는 100 이하의 자연수가 데이터의 정의역이므로, 0으로 설정하면 된다. 다음 으로 첫 번째 자료부터 마지막 자료까지 하나씩 검사해가며 현재까지 ans보다 더 큰 값이 나타나면 ans를 갱신하고, index값도 갱신한다.   마지막 자료까지 탐색을 마치면, ans와 index를 출력하면 된다. 이 과정을 입출력 예를 통해서 알아보자.            이와 같이 배열을 선형으로 전체탐색을 하면서 최댓값을 구할 수 있다. 이 방법은 가장 기본적인 방법 중 하나로 다른 알고리즘에 많이 응용되는 방법이다.   이를 프로그램으로 구현하면 다음과 같다.   #include &lt;stdio.h&gt;  #define MAXN 9 int ans, A[MAXN+1];  void solve(void) {   for(int i=1; i&lt;10; i++) {     scanf(\"%d\", A+i);     if(A[ans]&lt;A[i]) ans=i;    } } int main() {   solve();   printf(\"%d\\n%d\\n\", A[ans], ans);   return 0; }   ans, index를 하나의 변수 ans로 처리하고 있다. 그리고 9행에서 입력 받을 때 “&amp;A[i]” 대신 “A+i”를 활용하고 있다. 이러한 코딩 스타일도 자주 활용되는 방법으로 배열과 포인터를 이해하면 위와 같이 사용할 수 있음을 알 수 있다. 이와 같을 때에는 특수문자로 인한 오타의 확률도 줄일 수 있으므로 다양한 방법을 익힐 수 있도록 하자.   3의 배수 게임   3의 배수 게임을 하던 정올이는 3의 배수 게임에서 잦은 실수로  계속해서 벌칙을 받게 되었다. 3의 배수 게임의 왕이 되기 위한 마스터 프로그램을 작성해 보자.  ** 3의 배수 게임이란?  여러 사람이 순서를 정해 순서대로 수를 부르는 게임이다. 만약 3의 배수를 불러야 하는 상황이라면, 그 수 대신 \"박수\" 를 친다.  ----------------------------------------------  입력 첫 째 줄에 하나의 정수 n이 입력된다(n은 10000미만의 자연수이다.). 출력 1부터 그 수까지 순서대로 공백을 두고 수를 출력하는데,  3 또는 6 또는 9인 경우 그 수 대신 영문 대문자 X 를 출력한다.  입력 예      출력 예 7          1 2 X 4 5 X 7   이 문제도 앞선 문제와 마찬가지로 단순히 반복문을 이용하여 전체탐색법으로 해결할 수 있다. 단지 이 문제는 특정 값을 찾거나 하는 것이 아니라 전체 데이터를 읽으면서 특정 자료가 있으면 변경한다는 점은 다르나 전반적으로 같은 방법으로 해결할 수 있다. 이 문제에서 특정 자료란 입력된 숫자가 3의 배수일 경우를 말한다.   임의의 변수 n이 3의 배수인지 판정하는 가장 일반적인 방법은 다음과 같은 방법을 이용한다.   n % 3 == 0  1부터 n까지 1씩 증가하여 탐색하면서 각 수가 3의 배수인지 판정하여 3의 배수이면 “X”를 아니면 그 수를 출력하도록 작성하면 쉽게 해결할 수 있다.   이 문제를 해결한 예시는 다음과 같다.   #include &lt;stdio.h&gt;  int n; void solve(void) {   for(int i=1; i&lt;=n; i++) {     if(i%3==0) printf(\"X \");     else printf(\"%d \", i);   } } int main() {   scanf(\"%d\", &amp;n); s   solve();   return 0; }   linear structure search   n개로 이루어진 정수 집합에서 원하는 수의 위치를 찾으시오.  단, 입력되는 집합은 오름차순으로 정렬되어 있으며, 같은 수는 없다.  -------------------------------------------  입력 첫 줄에 한 정수 n이 입력된다. 둘째 줄에 n개의 정수가 공백으로 구분되어 입력된다. 셋째 줄에는 찾고자 하는 수가 입력된다. (단, 2 &lt;= n &lt;= 1,000,000, 각 원소의 크기는 100,000,000을 넘지 않는다.)  출력 찾고자 하는 원소의 위치를 출력한다. 없으면 -1을 출력한다.  입력 예                       출력 예 8                           1 2 3 5 7 9 11 15 11        7 11  3 2 5 7                       -1 3                 이 문제는 앞에서 다룬 이분탐색의 예제 프로그램을 거의 그대로 활용할 수 있는 문제이다.   이분탐색으로 풀어보자.   이분탐색 알고리즘   배열을 A라고 할 때, A[m] == k 인 경우와 A[m] &gt; k, A[m] &lt; k인 경우로 나누어 처리 하는 방법으로 문제를 해결할 수 있다.   탐색 범위를 [s, e]로 정한 다음, 이분탐색을 진행한다. (이분탐색 - 반복)      s &lt;= e를 만족할 때까지(만족하지 않으면 3번으로 간다), 가운데 위치의 값을 m( (s+e)/2 )으로 설정하고 탐색 진행.   A[m] == k인 경우, 찾았으므로 위치를 반환한다. (예제에서는 m+1)  A[m] &gt; k인 경우, 가운데 위치의 값이 찾고자 하는 값보다 크므로 탐색 범위를[s, m-1]로 하여 다시 이분탐색(1번으로 간다)  A[m] &lt; k인 경우, 가운데 위치의 값이 찾고자 하는 값보다 작으므로 탐색 범위를[m+1, e]로 하여 다시 이분탐색(1번으로 간다)   s &gt; e인 경우, 원하는 값이 없으므로 -1을 반환한다.   그림과 함께 자세한 과정을 보자.         위 방법을 소스코드로 작성하면 다음과 같다.   #include &lt;stdio.h&gt; int n, k, A[1000001];  int solve(int s, int e) {   int m;    while(s&lt;=e) {     m=(s+e)/2;      if(A[m]==k)       return m+1;      if(A[m]&lt;k) s=m+1;      else e=m‐1;   }   return ‐1; } int main() {   scanf(\"%d\",&amp;n);    for(int i=0; i&lt;n; i++ )     scanf(\"%d\", A+i);    scanf(\"%d\",&amp;k);    printf(\"%d\\n\", solve(0, n‐1));    return 0; }   위 소스코드를 다음과 같은 재귀함수로도 만들 수 있다. 재귀함수는 매우 다양한 응용이 가능하므로 이해해두면 많은 도움이 된다.   #include &lt;stdio.h&gt; int n, k, A[1000001];  int solve(int s, int e) {   if(s&gt;e)      return ‐1;   int m=(s+e)/2;    if(A[m]==k)     return m+1;    if(A[m]&lt;k)     return solve(m+1, e);    else     return solve(s, m‐1); } int main() {   scanf(\"%d\",&amp;n);    for(int i=0; i&lt;n; i++ )     scanf(\"%d\", A+i);    scanf(\"%d\",&amp;k);    printf(\"%d\\n\", solve(0, n‐1));    return 0; }   References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["이분탐색","순차탐색","Data structure","programming"],
        "url": "http://localhost:4000/algorithm/%EC%84%A0%ED%98%95%EA%B5%AC%EC%A1%B0%EC%9D%98-%ED%83%90%EC%83%89/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm43.png"},{
        "title": "트리(Tree)",
        "excerpt":"트리(Tree)   트리는 부모와 자식간의 관계가 계층적으로 구성되는 자료구조이다.  하나의 노드가 여러개의 자식들을, 다시 자식들은 다른 자식들을 가질 수 있는 구조이다.   다음 그림은 전형적인 트리를 보여준다.      트리 용어  트리에 쓰이는 용어들을 알아보자.   루트(Root)  트리의 계층적 구조상 가장 위에 위치한 노드를 지칭한다.  위의 그림에서 A가 루트이다.   루트는 유일하게 부모 노드가 없는 노드이다.   리프 노드(Reaf Node)  아무런 자식도 가지지 않는 노드를 리프 노드라고 한다.  위의 그림에서 E, F, C, G, H가 리프 노드이다.   조상 노드(Ancestor)  특정 노드에서 루트로의 선행자가 이에 해당한다.  노드 F의 조상 노드는 B, A가 된다.   형제 노드(Sibling)  같은 부모를 가지는 노드들을 형제 노드라고 한다.  위의 그림에서 B, C, D가 형제 노드이다.   서브 트리(Sub Tree)  위의 그림에서 A가 null이 아니면, 그 밑의 자식 트리 T1, T2, T3를 노드 A의 서브 트리라고 한다.   레벨(Level)  트리는 계층적 구조로서 레벨을 가지고 있다.  루트는 0레벨이며, 밑 자식으로 갈수록 레벨이 1씩 커진다.   이진 트리   한 노드가 최대 2개의 자식 노드를 가질 수 있는 트리를 이진 트리라고 한다.  한 노드의 왼쪽에 오는 자식을 왼쪽 자식 노드, 오른쪽에 오는 자식을 오른쪽 자식 노드라고 부른다.   다음은 전형적인 이진 트리를 나타내는 그림이다.      이진 트리의 종류   이진 트리를 구성하는 노드의 형태에 따라 다음과 같이 분류된다.   Full Binary Tree   모든 노드가 자식을 0개 혹은 2개 가진 트리를 일컽는다.   다음은 전부 Full Binary Tree이다.            18        /    \\         15      30        /  \\     /  \\    40   50  100   40              18            /    \\             15     20             /  \\              40    50        /   \\    30   50            18          /   \\           40   30               /  \\           100   40   Full Binary Tree에서 리프노드의 수는 내부노드의 수 + 1 이다.   Complete Binary Tree   트리의 마지막 레벨을 제외한 모든 레벨에서 노드가 자식을 두개 가지고 있고, 마지막 레벨에서는 왼쪽 부터 자식이 빠짐없이 차 있는 트리를 일컽는다.   다음은 전부 Complete Binary Tree 이다.                18            /    \\            15      30           /  \\    /  \\       40   50 100   40                18            /    \\            15      30           /  \\    /  \\       40   50  100 40      / \\   /     8  7  9    Binary Heap은 Complete Binary 트리이다.   Perfect Binary Tree   리프노드를 제외한 모든 내부노드가 자식 노드를 2개 가지고, 모든 리프노드가 동일 레벨 선상에 있는 트리를 일컽는다.   다음은 전부 Perfect Binary Tree 이다.                 18            /       \\  --- 높이 h: 3          15         30         /  \\        /  \\       40    50    100   40                18            /    \\  -- 높이 h: 2          15     30    Perfect Binary Tree의 높이가 h일 때 $2^h-1$개의 노드를 가진다.  (높이 h: 루트로부터 리프노드 까지의 경로에 있는 노드의 수)   Degenerate (or pathological) tree   트리의 내부노드가 오직 하나의 자식만을 갖는 트리를 일컽는다.   다음은 Degenerate tree 이다.       10     /    20     \\      30        \\        40       연결 리스트와 성능면에서 동일하다.   이진 트리 표현   이진 트리를 어떻게 표현하고 구현할 수 있을지 알아본다.   이진 트리 클래스는 최상위 노드를 가리키는 root 레퍼런스를 갖고 있다.   class BinaryTree  {      // Root of Binary Tree      Node root;         // Constructors      BinaryTree(int key)      {          root = new Node(key);      }         BinaryTree()      {          root = null;      }  }   또한 이진 트리 클래스는 각 노드를 표현할 노드 클래스를 가지고 있다.   class Node  {      int key;      Node left, right;         public Node(int item)      {          key = item;          left = right = null;      }  }    노드는 다음과 같은 부분으로 구성된다.      Data - 데이터를 저장하는 필드   왼쪽 자식에 대한 레퍼런스   오른쪽 자식에 대한 레퍼런스   트리 예제 코드   위의 표현들을 이용하여 트리를 만들어보고 이해해보자.   먼저 전체 코드이다.   /* Class containing left and right child of current     node and key value*/    // A Java program to introduce Binary Tree  class BinaryTree  {      // Root of Binary Tree      Node root;         // Constructors      BinaryTree(int key)      {          root = new Node(key);      }         BinaryTree()      {          root = null;      }       static class Node      {          int key;          Node left, right;             public Node(int item)          {          key = item;          left = right = null;          }      }         public static void main(String[] args)      {          BinaryTree tree = new BinaryTree();             /*create root*/         tree.root = new Node(1);             tree.root.left = new Node(2);          tree.root.right = new Node(3);          tree.root.left.left = new Node(4);      }  }    BinaryTree tree = new BinaryTree();    이진 트리를 생성하는 구문이다.  아직은 아무런 노드가 없으므로 root 레퍼런스는 null이다.    tree.root = new Node(1);  노드를 할당하여 1을 넣고, 트리의 root 레퍼런스가 할당된 노드를 가리키게 한다.   그림으로 표현하면 다음처럼 도식화 된다.                 1              /   \\            null  null    1번 노드는 루트가 되었다.  1번 노드의 왼쪽, 오른쪽 자식노드는 없으므로 left, right 레퍼런스는 null이다.   그 다음을 보자.   tree.root.left = new Node(2);  tree.root.right = new Node(3);   노드를 할당하여 2를 넣고, 트리의 root 왼쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다. 노드를 할당하여 3을 넣고, 트리의 root 오른쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다. 2, 3번 노드는 아직 자식들이 없으므로 left, right 레퍼런스는 null이다.   그림으로 표현하면 다음과 같다.                   1               /    \\              2       3            /   \\    /  \\          null null null null   계속해서 그 다음을 보자.   tree.root.left.left = new Node(4);   노드를 할당하여 4를 넣고, root의 왼쪽 노드의 왼쪽 자식 레퍼런스가 할당된 노드를 가리키게 한다.   그림으로 표현하면 다음과 같다.                       1                  /       \\                 2          3               /   \\       /  \\              4    null  null  null             /   \\            null null    4번 노드는 2번 노드의 자식이 되었다.   References  GeeksforGeeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Linked List","Tree"],
        "url": "http://localhost:4000/data%20structure/Tree/",
        "teaser":null},{
        "title": "이진 탐색 트리-예정포스트",
        "excerpt":" ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure","Tree"],
        "url": "http://localhost:4000/data%20structure/binary-search-tree/",
        "teaser":"http://localhost:4000/assets/images/tree1.png"},{
        "title": "트리의 순회(Tree Traversal)",
        "excerpt":"트리의 순회(Tree Traversal)   트리를 순회하는데 여러가지 방법이 있지만 이번 포스트에서는 그 중 깊이우선탐색(DFS)의 성질을 가진 3가지 순회 방법을 알아본다.   다음은 트리를 순회하는 대표적인 3가지 방법이다. (깊이우선탐색(DFS))      Inorder - 중위 순회   Preorder - 전위 순회   Postorder - 후위 순회   3가지 순회들은 다음의 공통된 패턴을 가지고 있다.   (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.  (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.  (N) 현재 노드를 방문한다.   모든 노드에 대해서, 이 패턴들이 실행되는 순서에 따라 3가지 순회 방법이 결정되게 된다.   여기서 ‘재귀적으로’라는 말은 작업이 다른 서브루틴으로 분기된다는 뜻이다.  서브루틴에서의 작업이 끝나게 되면 다시 현재의 작업으로 백트랙하게 된다.   Inorder - 중위 순회   트리의 중위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.   중위 순회(LNR)  현재 노드가 null인지 확인한다.   아니라면 다음의 순서대로 순회를 한다.    (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.   (N) 현재 노드를 방문한다.   (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.    다음의 그림은 Inorder의 예를 보여준다.      위의 그림에서 볼 수 있듯이, 어떤 노드가 처리되기 전에 왼쪽 서브트리가 먼저 처리되고(L) 그 다음 해당 노드가 처리되고(N) 그 다음 오른쪽 서브트리 처리된다(R).   모든 노드에 대해서 (L), (R) 연산들은 재귀적으로 수행이 된다.   다음은 위를 구현한 자바 코드이다.   // Recursive function to perform in-order traversal of the tree public static void inorder(TreeNode root) { \t// 현재 노드가 null이면 리턴 \tif (root == null) { \t\treturn; \t}  \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tinorder(root.left);  \t// 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \");  \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tinorder(root.right); }   Preorder -  전위 순회   트리의 전위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.   전위 순회(NLR)  현재 노드가 null인지 확인한다.   아니라면 다음의 순서대로 순회를 한다.    (N) 현재 노드를 방문한다.   (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.   (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.    다음의 그림은 Preorder의 예를 보여준다.      위의 그림에서 볼 수 있듯이, 해당 노드가 처리되고(N) 그 다음 왼쪽 서브트리가 처리되고(L) 마지막으로 오른쪽 서브트리가 처리된다(R).   모든 노드에 대해서 (L), (R) 연산들은 재귀적으로 수행이 된다.   다음은 위를 구현한 자바 코드이다.   // Recursive function to perform pre-order traversal of the tree public static void preorder(TreeNode root) { \t// return if the current node is empty \tif (root == null) { \t\treturn; \t} \t// 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \");  \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tpreorder(root.left);  \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tpreorder(root.right); }   Postorder - 후위 순회   트리의 후위 순회를 위해서 루트 노드 부터 모든 노드에 대해 다음의 작업을 수행한다.   후위 순회(LRN)  현재 노드가 null인지 확인한다.   아니라면 다음의 순서대로 순회를 한다.    (L) 현재 노드의 왼쪽 서브트리를 재귀적으로 순회한다.   (R) 현재 노드의 오른쪽 서브트리를 재귀적으로 순회한다.   (N) 현재 노드를 방문한다.    다음의 그림은 Postorder의 예를 보여준다.      위의 그림에서 볼 수 있듯이, 해당 노드가 처리되기 전에 왼쪽 서브트리가 먼저 처리되고(L) 그 다음 오른쪽 서브트리 처리되고(R) 마지막으로 해당 노드가 처리된다(N).   모든 노드에 대해서 (L), (R) 연산들은 재귀적으로 수행이 된다.   다음은 위를 구현한 자바 코드이다.   // Recursive function to perform post-order traversal of the tree public static void postorder(TreeNode root) { \t// return if the current node is empty \tif (root == null) { \t\treturn; \t}  \t// 재귀적으로 왼쪽 서브트리를 탐색한다. \tpostorder(root.left);  \t// 재귀적으로 오른쪽 서브트리를 탐색한다. \tpostorder(root.right);    // 현재 노드의 데이터를 출력한다. (방문) \tSystem.out.print(root.data + \" \"); }   References  GeeksforGeeks  ","categories": ["Algorithm"],
        "tags": ["programming","Traversal","DFS","Tree"],
        "url": "http://localhost:4000/algorithm/treeTraversal/",
        "teaser":null},{
        "title": "그래프(Graph)",
        "excerpt":"Graph  정점들과 간선들로 이루어진 집합이다.   Definition  V: Vertex, E: Edge, G: Graph  그래프 G는 G(V, E)의 집합으로 정의 될 수 있다 =&gt; G = (V, E)  V(G)는 정점의 집합 그리고 E(G)는 두 정점들의 연결을 나타내는 간선의 집합이다.   Info: 그래프는 트리를 포함하는 개념이고, 트리는 사이클을 포함하지 않는 그래프라고 볼 수 있다.  그래서 모든 트리는 그래프이지만, 모든 그래프는 트리가 아니다.   Undirected and Directed Graph   그래프는 방향 그래프 또는 비방향 그래프가 될 수 있다.   비방향 그래프는 두 정점 간의 간선에 방향이 없다.  A - B의 비방향 간선이 있다면, 이것은 A -&gt; B로, B -&gt; A로의 탐색이 가능하다는 것을 의미한다.   방향 그래프는 두 정점 간의 간선에 방향을 가지고 있다.  A -&gt; B의 방향 간선이 있다면, 이것은 A -&gt; B로의 탐색이 가능, 그러나 B -&gt; A로의 탐색이 가능하지 않다는 것을 의미     Unweighted and weighted Graph   두 정점 간의 간선에 추가 정보가 없다면 Unweighted(비가중치) 그래프.  두 정점 간의 간선에 추가 정보가 있다면 weighted(가중치) 그래프.      Representation  그래프를 표현하는 2가지 방법을 알아본다.  인접 행렬(Adjacency matrix)   2차원 행렬로 표현하는 방법.  행은 출발 정점을 나타내고 열을 도착 정점을 나타낸다. 꼭짓점 x에서 꼭짓점 y로 변이 존재하면 행렬 성분 x행 y열의 값은 1이고 그렇지 않으면 0이다.      Note: 그래프가 100개의 정점과 1개의 간선으로 이루어져 있어도, 인접행렬 표현 시 100x100 크기의 매트릭스를 써야한다. 즉, 비교적 적은 간선의 그래프를 표현하는데에는 불필요한 공간이 많이 소비된다.   인접 리스트(Adjacency list)  인접 리스트를 이용하여 그래프를 표현하는 방법  이 표현에서는, 각 정점이 인접리스트 배열로 표현이 되어 있고, 자신과 인접한 노드들을 리스트로 연결한다.   표현방식: A - B 와 같이 방향성이 없을 때는 A의 인접리스트에 B 원소를 추가하고, B의 뒤에도 A를 추가한다.  A -&gt; B 와 같이 방향성이 있을 때는 A의 인접리스트에 B 원소만 추가한다.      Note: 위 그래프는 방향 그래프임에 주의하라.  A 정점은 B와 C 노드와 이웃하므로 A의 인접리스트 뒤로 B와 C의 원소가 따라 붙는다.  B 정점은 D와 E 노드와 이웃하므로 B의 인접리스트 뒤로 D와 E의 원소가 따라 붙는다.   Pros: 인접 행렬 방식에 비해 메모리 공간을 많이 절약할 수 있다.  각 정점들 간의 이웃관계를 보다 쉽고 확실하게 표현할 수 있다.   Cons: 두 정점이 서로 연결되어 있는지 찾는 연산은 인접 행렬에 비해 다소 느리다.   Implementation   Example Graph  예제에서 나타내고자 하는 그래프는 다음과 같다.   Graph G (Bidirectional):  V = (0, 1, 2, 3, 4) E = (0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4)  G: 0 ------ 2 |      /   \\ |    /      4 |  /       / 1 ------ 3    위 그래프로 부터 표현되어지는 인접 리스트는 다음과 같다.   0 =&gt; 1 =&gt; 2       // 0번 정점은 1, 2번 정점과 연결되어 있다. 1 =&gt; 0 =&gt; 2 =&gt; 3  // 1번 정점은 0, 2, 3번 정점과 연결되어 있다. 2 =&gt; 0 =&gt; 1 =&gt; 4  // 2번 정점은 0, 1, 4번 정점과 연결되어 있다. 3 =&gt; 1 =&gt; 4       // 3번 정점은 1, 4번 정점과 연결되어 있다. 4 =&gt; 2 =&gt; 3   Graph Class  public class Graph {     private int V; // 그래프의 정점 갯수     private LinkedList&lt;Integer&gt; adjListArray[]; // 그래프의 정점을 저장할 인접리스트 배열      public Graph(int V) { // 그래프 생성자, 정점과 인접리스트 배열을 초기화 한다.         this.V = V;         adjListArray = new LinkedList[V]; // 인접리스트 배열 생성         for (int i = 0; i &lt; V; i++) {             adjListArray[i] = new LinkedList&lt;&gt;(); // 인접리스트 노드 초기화 및 생성         }     } }    addEdge  // 양방향 간선 정보 저장 static void addEdge(Graph graph, int src, int dest) {      graph.adjListArray[src].add(dest); // src -&gt; dest     graph.adjListArray[dest].add(src); // dest -&gt; src }    Graph.java  import java.util.LinkedList;  public class Graph {     private int V; // 그래프의 정점 갯수     LinkedList&lt;Integer&gt; adjListArray[]; // 그래프의 정점을 저장할 인접리스트 배열      public Graph(int V) { // 그래프 생성자, 정점과 인접리스트 배열을 초기화 한다.         this.V = V;         adjListArray = new LinkedList[V];         for (int i = 0; i &lt; V; i++) {             adjListArray[i] = new LinkedList&lt;&gt;();         }     }     // 그래프 출력 메소드     public void printGraph() {         for (int v = 0; v &lt; V; v++) {             System.out.print(v);             for (Integer i : adjListArray[v]) {                 System.out.print(\" =&gt; \" + i);             }             System.out.print(\"\\n\");         }     }     // 양방향 간선 생성 메소드     static void addEdge(Graph graph, int src, int dest) {         graph.adjListArray[src].add(dest);         graph.adjListArray[dest].add(src);     }       public static void main(String[] args) {         int V = 5; // 정점의 갯수는 5개 (0, 1, 2, 3, 4)         Graph graph = new Graph(V); // 그래프 초기화          addEdge(graph, 0, 1); // 0번과 1번을 정점으로 하는 간선을 생성한다.         addEdge(graph, 0, 2); // 0번과 2번을 정점으로 하는 간선을 생성한다.         addEdge(graph, 1, 2); // 1번과 2번을 정점으로 하는 간선을 생성한다.         addEdge(graph, 1, 3);         addEdge(graph, 2, 4);         addEdge(graph, 3, 4);          graph.printGraph();     } }  Output: 0 =&gt; 1 =&gt; 2       // 0번 정점은 1, 2번 정점과 연결되어 있다. 1 =&gt; 0 =&gt; 2 =&gt; 3  // 1번 정점은 0, 2, 3번 정점과 연결되어 있다. 2 =&gt; 0 =&gt; 1 =&gt; 4  // 2번 정점은 0, 1, 4번 정점과 연결되어 있다. 3 =&gt; 1 =&gt; 4       // 3번 정점은 1, 4번 정점과 연결되어 있다. 4 =&gt; 2 =&gt; 3       // 4번 정점은 2, 3번 정점과 연결되어 있다.   References  Graph - Wikipedia  Graph - javapoint  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure"],
        "url": "http://localhost:4000/data%20structure/graph/",
        "teaser":null},{
        "title": "Restful API Authentication App",
        "excerpt":"Restful API Authentication App   Used Packages, Libraris, Dependencies and Database in the project.     Node.js   Express.js: Node.js package   nodemon: To restart server   Mongoose: DB package   MongoDB: To save user data   bcryptjs: Encrypt the user’s password so that 3rd party don’t see   dotenv: Configuration private setting data   @hapi/joi: To validate user input form data   Make sure   Make sure that node.js must be installed in your computer.   Make sure that you must have your own mongoDB cluster.  Make sure that postman which is used to requset get or post method with data to server should be installed.   Usage      clone the repository.   Inside .env file, Replace  with your mongoDB account password.   Open the terminal.   Start Server by typing ‘npm start’ or ‘npm run dev’ in the terminal (Make sure that except for quotation mark in the terminal).   Open the postman   Try to send ‘POST’ request with JSON data(below 6) format with URL - http://localhost:5000/api/user/register   Try with Example JSON data =&gt; { “name”: “lemidia”, “email”: “poiu2186@gmail.com”, “password”:”own password” }   Once you have done this, Try to send ‘POST’ request with JSON data(below 7) format with URL - http://localhost:5000/api/user/login   Try with Example JSON data =&gt; { “poiu2186@gmail.com”, “password”:”&lt;own passowrd” }   Repository   Github - lemidia  ","categories": ["Development"],
        "tags": ["Development","JavaScript","Node.js","API"],
        "url": "http://localhost:4000/development/restfulauth/",
        "teaser":null},{
        "title": "큐(Queue)",
        "excerpt":"Queue  큐(queue)는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO (First In First Out)구조로 저장하는 형식을 말한다. 영어 단어 queue는 표를 사러 일렬로 늘어선 사람들로 이루어진 줄을 말하기도 하며, 먼저 줄을 선 사람이 먼저 나갈 수 있는 상황을 연상하면 된다.      Representation     Array: 기본적으로 배열을 사용해서 큐를 구현할 수 있다.   Linked List: 링크드 리스트를 이용하면 배열에 비해 쉽게 구현이 가능하다.   Note: 이번 포스트에서는 자바로 Linked List를 이용해서 큐를 구현해 본다.   Queue Node - 큐 원소를 표현하기 위한 노드 클래스   // A linked list (LL) node to store a queue entry  class QNode {      int key;      QNode next;         // constructor to create a new linked list node      public QNode(int key)      {          this.key = key;          this.next = null;      }  }   Queue Node - 큐를 표현하는 클래스   class Queue {      QNode front, rear;         public Queue()      {          this.front = this.rear = null;      }  }   Note: 큐는 맨 처음 원소를 가리키는 front와 맨 끝 원소를 가리키는 rear 포인터를 가지고 있다.   Operation  큐가 지원하는 연산들을 알아보자.      Enqueue: 큐의 맨 끝에 원소를 추가하는 연산.   Dequeue: 큐의 맨 처음의 원소를 삭제하고 반환하는 연산. 큐가 비었으면 null을 반환한다.   Enqueue - 원소 추가 연산  void enqueue(int key) {      // Create a new LL node      QNode temp = new QNode(key);       // If queue is empty, then new node is front and rear both      if (this.rear == null) {          this.front = this.rear = temp;          return;      }       // Add the new node at the end of queue and change rear      this.rear.next = temp;      this.rear = temp;  }   Dequeue - 원소 삭제 연산   QNode dequeue() {      // If queue is empty, return NULL.      if (this.front == null)          return null;       // Store previous front and move front one node ahead      QNode temp = this.front;      this.front = this.front.next;       // If front becomes NULL, then change rear also as NULL      if (this.front == null)          this.rear = null;      return temp;  }   Queue Implementation - 전체 코드   // A linked list (LL) node to store a queue entry  class QNode {      int key;      QNode next;         // constructor to create a new linked list node      public QNode(int key)      {          this.key = key;          this.next = null;      }  }   // A class to represent a queue  // The queue, front stores the front node of LL and rear stores the  // last node of LL  class Queue {      QNode front, rear;         public Queue()      {          this.front = this.rear = null;      }         // Method to add an key to the queue.      void enqueue(int key)      {             // Create a new LL node          QNode temp = new QNode(key);             // If queue is empty, then new node is front and rear both          if (this.rear == null) {              this.front = this.rear = temp;              return;          }             // Add the new node at the end of queue and change rear          this.rear.next = temp;          this.rear = temp;      }         // 큐에서 원소를 삭제하는 연산     QNode dequeue()      {          // If queue is empty, return NULL.          if (this.front == null)              return null;             // Store previous front and move front one node ahead          QNode temp = this.front;          this.front = this.front.next;             // If front becomes NULL, then change rear also as NULL          if (this.front == null)              this.rear = null;          return temp;      }  }     // Driver class  public class Test {      public static void main(String[] args)      {          Queue q = new Queue();          q.enqueue(10);          q.enqueue(20);          q.dequeue();          q.dequeue();          q.enqueue(30);          q.enqueue(40);          q.enqueue(50);             System.out.println(\"Dequeued item is \" + q.dequeue().key);      }  }    Queue q = new Queue();  빈 큐가 생성이 된다.  현재: q = []  q.enqueue(10);  q.enqueue(20);  (10, 20)이 들어온다.  현재: q = [10, 20];  q.dequeue();  q.dequeue();  (10, 20)이 나간다.  현재: q = [];  q.enqueue(30);  q.enqueue(40);  q.enqueue(50);  (30, 40, 50)이 차례대로 들어온다.  현재: q = [30, 40, 50];  System.out.println(\"Dequeued item is \" + q.dequeue().key);  디큐 연산으로 인해 맨앞의 30이 삭제되고 반환된다.  Output: Dequeued item is 30   자바가 제공하는 큐   자바에서는 Queue Interface를 구현한 Linked List Class를 제공한다.   큐 선언: Queue&lt;T&gt; queue = new LinkedList&lt;T&gt;();  큐 연산: queue.offer(); // 삽입 연산 queue.pop();   // 삭제하고 원소 반환 queue.peek();  // 큐의 맨 앞 원소 반환 queue.isEmpty(); // 큐가 비었는지 확인   Time Complexity  Algorithm   Average  WorstCase Space       O(n)     O(n) Search      O(n)     O(n) Insert      O(1)     O(1) Delete      O(1)     O(1)   References  Queue - Wikipedia   Queue - Geeks  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure"],
        "url": "http://localhost:4000/data%20structure/queue/",
        "teaser":null},{
        "title": "자바스크립트를 이용한 날씨 웹 앱",
        "excerpt":"앱 개요   웹 화면 상으로 사용자의 지역 날씨 상태를 보여주는 웹 어플리케이션.   Look      설명   사용자가 웹 앱에 접속하면 사용자로부터 위치정보 엑세스에 대한 허용 여부를 묻는다.  허용이 되면 자바스크립트의 navigator.geolocation으로 부터 사용자의 위도와 경도 값을 읽어낸다.  DarkSky API로 부터 받은 사용자 키 값에 위도와 경도값을 넣어준다.  API로 부터 읽어낸 JSON 데이터를 자바스크립트 객체로 변환하여 앱에서 필요한 데이터를 얻는다.   사용되는 것들     HTML - 웹 엘리먼트 구조   CSS - 스타일 꾸미기 및 레이아웃   Pure JavaScript - 사용자 위치정보, Dom Tree 조작, 온도 계산   DarkSky Api - 날씨 정보를 받아오기 위해 사용 (월 1000건 까지의 쿼리는 무료)   SkyCons - DarkSky Api에서 제공하는 날씨 아이콘   실행 방법   하나의 폴더에 밑의 index.html, style.css, app.js파일을 넣어준다.  그리고, 날씨 데이터 사이트에 가서 Try For Free를 눌러 가입하여 API키 값을 얻어낸 다음  app.js 파일의 “자신의 키” 부분에 API 키 값을 넣어준다.  // app.js파일의 &lt;자신의 키&gt; 부분에 API 키 값을 넣어준다. const api = `${proxy}https://api.darksky.net/forecast/&lt;자신의 키&gt;/${lat}, ${long}`;   Source Code   index.html   &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;     &lt;link rel=\"stylesheet\" href=\"./style.css\"&gt;     &lt;title&gt;Weather&lt;/title&gt; &lt;/head&gt; &lt;body&gt;      &lt;div class=\"location\"&gt;         &lt;h1 class=\"location-timezone\"&gt;Loading Location Data ...&lt;/h1&gt;         &lt;canvas id=\"icon1\" width=\"128\" height=\"128\"&gt;&lt;/canvas&gt;     &lt;/div&gt;     &lt;div class=\"temperature\"&gt;         &lt;div class=\"degree-section\"&gt;             &lt;h2 class=\"temperature-degree\"&gt;?&lt;/h2&gt;             &lt;span class=\"transition\"&gt;C&lt;/span&gt;         &lt;/div&gt;         &lt;div class=\"temperature-description\"&gt;Loading Data ... &lt;/div&gt;     &lt;/div&gt;     &lt;script src=\"./app.js\"&gt;&lt;/script&gt;     &lt;script src=\"skycons.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  style.css  *{     margin: 0;     padding: 0;     box-sizing: border-box; }  body{     height: 100vh;     display: flex;     justify-content: center;     flex-direction: column;     align-items: center;     background: linear-gradient(rgb(47,150,163), rgb(48, 62, 143));     font-family: sans-serif;     color: white; }  .location, .temperature{     height: 20vh;     width: 50%;     display: flex;     justify-content: space-around;     align-items: center; }  .temperature{     flex-direction: row;     align-items: baseline; }  .temperature-description{     font-size: 2rem;     transform: translateX(20%); }  .degree-section{     display: flex;     align-items: center;     cursor: pointer;     transform: translateX(30%); }  .degree-section span{     margin: 7px;     font-size: 35px; }  .degree-section h2{     font-size: 40px; }  @media screen and (max-width:550px){     .location-timezone{         margin-right: 3rem;     }      .degree-section{         margin-right: 6rem;         font-size: 30px;     }      .temperature-description{         transform: translateX(-20%);     } }  app.js  window.addEventListener('load', () =&gt;{     let long;     let lat;     let temperatureDescription = document.querySelector('.temperature-description');     let temperatureDegree = document.querySelector('.temperature-degree');     let locationTimezone = document.querySelector('.location-timezone');          if (navigator.geolocation) {         navigator.geolocation.getCurrentPosition( position =&gt; {             long = position.coords.longitude;             lat = position.coords.latitude;             const proxy = 'https://cors-anywhere.herokuapp.com/';             const api = `${proxy}https://api.darksky.net/forecast/&lt;자신의 키&gt;/${lat}, ${long}`;              fetch(api)                 .then(response =&gt; {                  return response.json();                 })                  .then(data =&gt; {                    console.log(data);                    const {dewPoint, summary, icon} = data.currently;                    // Set DOM Elements from the API                    temperatureDegree.textContent = Math.round((dewPoint - 32) / 1.8);                    temperatureDescription.textContent = summary;                    locationTimezone.textContent = data.timezone.replace(\"/\", \" / \");                    setIcons(icon, \"icon1\");                   });         }, () =&gt; {             alert(\"You have denied or please confirm location\");         });     } else{         alert(\"Geolocation is not supported by your browser\");     }     function setIcons(icon, iconID){         const skycons = new Skycons({color : \"white\"});         const weatherCondition = icon.replace(/-/g, \"_\").toUpperCase();         skycons.set(iconID, Skycons[weatherCondition]);         skycons.play();     }      let degreeSection = document.querySelector('.degree-section');     let transition = document.querySelector('.transition');     let isCelsius = true;     degreeSection.addEventListener('click', () =&gt; {         if (isCelsius) {             temperatureDegree.textContent              = Math.round(parseInt(temperatureDegree.textContent) * 1.8 + 32);             transition.textContent = 'F';             isCelsius = false;         }else{             temperatureDegree.textContent              = Math.round((parseInt(temperatureDegree.textContent) - 32) / 1.8);             transition.textContent = 'C';             isCelsius = true;         }     }) });  References   [Dev Ed - Youtube]  ","categories": ["Development"],
        "tags": ["JavaScript","Web","API"],
        "url": "http://localhost:4000/development/weather-app/",
        "teaser":null},{
        "title": "버블소트(Bubble Sort)",
        "excerpt":"Bubble(버블 정렬)   비교 기반 정렬 알고리즘이다.   정렬이 실행되면서 마치 형태가 거품이 수면위로 떠오르는 것 같은 모양을 한다고 하여 붙여진 이름이다.   인접한 두 원소를 비교하여 기준에 따라 스왑하고, 한 칸씩 옆으로 가면서 이를 n번째 원소까지 반복한다.   이를 모든 원소에 대해 n번 반복한다.  (최적화를 하면 배열의 원소 위치상태에 따라 횟수가 n번 보다 낮아질 수 있다.)   다른 O(nlongn)의 성능을 내는 정렬 알고리즘에 비해 성능이 좋지 않으므로 실무에서는 사용되지 않고 교육용 목적으로 사용 되어진다.   더 효율적인 정렬 알고리즘인 팀소트(Timsort)나 머지소트(Merge sort)가 인기있는 프로그래밍 언어(java, python)의 내장 정렬 라이브러리로 사용되고 있다.    Algorithm   밑의 애니메이션을 먼저 보고 알고리즘을 읽으면 이해가 빠를 수 있다.      처음 원소를 시작으로 n번째 원소까지 차례대로 인접한 원소와 오른쪽으로 비교하며 스왑을 진행한다.   n번째 원소와 비교가 끝이나면 n번째 원소는 정렬이 완료된 것이다.   다시 처음 원소부터 n-1번째 원소까지 인접한 원소와 비교하며 필요하면 스왑을 한다.   n-1번째 원소와 비교가 끝이나면 n-1번째 원소는 정렬이 완료된 것이다.   이를 반복하여, n-2..n-3..2번째 원소까지 정렬이 완료되면 알고리즘은 끝이난다.   Animation - Bubble sort     Analysis   버블소트는 최악과 평균 시간복잡도가 $O(n^2)$인 (2중 루프로 인해) 정렬 알고리즘이다.   최악과 평균 시간복잡도가 $O(nlog_{2}n)$인 실용적인 정렬 알고리즘 보다 성능이 좋지않고  시간복잡도가 $O(n^2)$인 삽입정렬도 버블소트보다는 빠르게 동작하기 때문에 버블소트는 다소 실용적인 정렬 알고리즘이 아니다.   다른 정렬들과 비교해(삽입정렬을 제외한) 버블소트의 최대 장점은 배열이 정렬되어 있는 것을 탐지해낼 수 있는 능력이다.   리스트가 정렬이 완료되어 있을 때의 버블정렬은 O(n)이다.   Step-by-step example   배열 [5 1 4 2 8]이 있다고 하자.   처음 원소부터 끝 원소까지 오름차순으로 버블소트를 이용하여 정렬하려고 한다.   첫번째 패스   ( 5 1 4 2 8 ) → ( 1 5 4 2 8 )   첫번째 원소와 두번째 원소를 비교한다, 5 &gt; 1 이므로 스왑한다.  ( 1 5 4 2 8 ) → ( 1 4 5 2 8 )   두번째 원소와 세번째 원소를 비교한다, 5 &gt; 4 이므로 스왑한다.  ( 1 4 5 2 8 ) → ( 1 4 2 5 8 )   세번째 원소와 네번째 원소를 비교한다, 5 &gt; 2 이므로 스왑한다.  ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )   네번째 원소와 다섯번째 원소를 비교한다, 5 &lt; 8 이므로 그대로 둔다.  첫번째 패스가 끝났다.  두번째 패스  ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )   첫번째 원소와 두번째 원소를 비교한다, 1 &lt; 4 이므로 그대로 둔다. ( 1 4 2 5 8 ) → ( 1 2 4 5 8 )   두번째 원소와 세번째 원소를 비교한다, 4 &gt; 2 이므로 스왑한다.  ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   세번째 원소와 네번째 원소를 비교한다, 4 &lt; 5 이므로 그대로 둔다. ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   첫번째 원소와 두번째 원소를 비교한다, 5 &lt; 8 이므로 그대로 둔다.  두번째 패스가 끝났다.  이제, 배열은 이미 오름차순으로 정렬이 완료되었다. 그러나, 알고리즘은 정렬이 완료되었는지 아직 모른다.  정렬이 완료되었는지 알기 위해선 하나의 패스를 더 거쳐야 한다.  (불리언 변수 하나를 두어 이를 알 수 있는데, 밑의 구현에서 알아본다.)  세번째 패스  ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )   ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )    세번째 패스가 끝났다.  스왑된 원소가 없으므로 알고리즘은 더 이상 패스를 수행하지 않는다.  알고리즘을 종료한다.   Implementation   다음은 버블소트를 의사코드로 구현한 것이다.   버블소트 의사코드 구현 (index is 0 base)   procedure bubbleSort(A : list of sortable items)     n := length(A) // 배열 길이, 원소 개수     repeat // 반복한다.         swapped = false // 스왑이 되었는지 여부         for i := 1 to n - 1 inclusive do // [1 ~ n-1]까지             /* 만약 두 원소가 순서에 어긋나면 */             if A[i - 1] &gt; A[i] then                 /* 스왑하고, 스왑되었다는 것을 체크한다. */                 swap(A[i - 1], A[i])                 swapped := true              end if         end for     // 스왑이 안되었을때 까지, 즉, swapped가 true면 repeat로 간다.     until not swapped end procedure   버블소트 최적화   n번째 패스가 끝이나면 n번째로 큰 원소는 이미 정렬이 완료되어 그자리에 위치가 변하지 않기에, 내부 루프는 매 패스마다, 0번째 부터 n번째 까지 원소를 비교할 필요가 없다.   한번의 패스가 끝이나면 n을 n-1로, 즉 1씩 줄여 쓸때없는 연산을 피할 수 있다.   procedure bubbleSort(A : list of sortable items)     n := length(A)     repeat         swapped := false         for i := 1 to n - 1 inclusive do             if A[i - 1] &gt; A[i] then                 swap(A[i - 1], A[i])                 swapped = true             end if         end for         // n을 1 감소시켜 다음번 패스 때 불필요한 연산을 하지 않는다.         n := n - 1     until not swapped end procedure   한가지 더 최적화를 해보자.   한 번의 패스로 하나 이상의 원소가 최종 정렬된 자리에 올 수 있다.  그렇다면 우리는 최종 정렬된 원소를 굳이 비교하지 않고 스킵할 수 있다.   다음은 이를 구현한 슈도 코드이다.   새로운 변수 newn을 주목하라.   procedure bubbleSort(A : list of sortable items)     n := length(A)     repeat         // newn: 몇 번째 원소까지 비교가 완료 되었는지         newn := 0         for i := 1 to n - 1 inclusive do             if A[i - 1] &gt; A[i] then                 swap(A[i - 1], A[i])                 newn := i             end if         end for         n := newn         // n이 1보다 작거나 같으면 반복문을 빠져 나온다.     until n ≤ 1 end procedure   [3 2 1 4 5]인 배열이 있다고 해보자.   첫번째 패스를 거치면  인덱스 0~4번 까지 비교를 하게 된다.  [2 1 3 4 5]가 된다.   이 때, newn은 2가 된다.  이는 2번 인덱스에서 마지막으로 스왑이 되었고, 그 이후로는 스왑이되지 않았다.  즉, 그 이후로는 정렬이 완료되었으니 정렬이 불필요하다는 것을 의미한다.   두번때 패스에서는  원래 대로라면 인덱스 0~3번 까지 비교를 하게 되겠지만  최적화를 거치면 첫번째 패스에서 newn은 2인 것을 아니까  인덱스 0~3, 0~2를 스킵하고, 0~1번 까지만 비교가 진행되게 된다.   이로서 불필요한 패스를 줄임으로서 최악 기준 약 50%의 성능 향상을 기대할 수 있다.   시간복잡도   최악 시간복잡도\t$O(n^2)$  최선 시간복잡도\t$O(n)$ - 배열이 이미 정렬 완료되었을 때  평균 시간복잡도\t$O(n^2)$   References   Bubble Sort - wikipedia  ","categories": ["Algorithm"],
        "tags": ["Sort","Array","Mathematics"],
        "url": "http://localhost:4000/algorithm/bubble-sort/",
        "teaser":null},{
        "title": "에라토스테네스의 체(Eratosthenes's Sieve)",
        "excerpt":"에라토스테네스의 체   수학에서 에라토스테네스의 체는 보다 빠르게 소수를 찾는 방법입니다.  고대 그리스 수학자 에라토스테네스가 발견하였습니다.     선행지식: 수학에서 소수란?   소수: 1을 제외한 수 중에서 1과 자기 자신을 제외하고 약수를 가지지 않는 수를 말합니다.   예)   예1) 2는 1과 자기 자신(2)을 제외하고는 약수를 가지지 않습니다. 소수입니다. 예2) 5는 1과 자기 자신(5)을 제외하고는 약수를 가지지 않습니다. 소수입니다. 예3) 13은 1과 자기 자신(13)을 제외하고는 약수를 가지지 않습니다. 소수입니다. 예4) 15는 1과 자기자신(15)를 제외하고도 3, 5의 약수를 가집니다. 소수가 아닙니다.   Algorithm   밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.      2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다. 그림에서 회색 사각형으로 두른 수들이 여기에 해당한다.   2는 소수이므로 오른쪽에 2를 쓴다. (빨간색)   자기 자신을 제외한 2의 배수를 모두 지운다.   남아있는 수 가운데 3은 소수이므로 오른쪽에 3을 쓴다. (초록색)   자기 자신을 제외한 3의 배수를 모두 지운다.   남아있는 수 가운데 5는 소수이므로 오른쪽에 5를 쓴다. (파란색)   자기 자신을 제외한 5의 배수를 모두 지운다.   남아있는 수 가운데 7은 소수이므로 오른쪽에 7을 쓴다. (노란색)   자기 자신을 제외한 7의 배수를 모두 지운다.   위의 과정을 반복하면 구하는 구간의 모든 소수가 남는다.      Note: 만약 x까지의 소수를 구한다고 하면 우리는 x까지 검사하여 일일히 지울 필요가 없습니다.  x는 &gt;= $\\sqrt {x}$ * $\\sqrt {x}$으로 표현 할 수 있고, $\\sqrt {x}$까지 수를 지우면, 그 이후의 수들은 이미 $\\sqrt {x}$까지의 수에서 지워졋기 때문입니다.  예) x를 16 이라고 해봅시다. $\\sqrt {x}$은 4 입니다.  8은 16의 약수입니다. 하지만 8은 이미 전 단계 2에서 지워졌습니다. 2 * 8이기 때문입니다.  예제에서는 120까지 구하고 있으므로 120의 제곱근 $\\sqrt {120}$ = 10까지만 지워도 됩니다.  왜냐하면 $\\sqrt {120}$ = 10 이후의 배수들은 이미 전 단계에서 지워졋기 때문입니다.   Java로 구현  import java.util.Arrays;  public class Eratosthenes {     private static final int MAX = 30;      public static void main(String[] args) {          boolean [] flag = new boolean[MAX];         Arrays.fill(flag, true);         eratosthenes(flag, MAX);         for (int i = 2; i &lt; flag.length; i++){             if (flag[i]){                 System.out.println(i + \" is prime number\");             }         }     }      public static void eratosthenes(boolean[] flag, int k){         for (int i = 2; i*i &lt; k ; i++) {             if (flag[i]){                 for (int j = i*i; j &lt; k ; j+=i) {                     flag[j] = false;                 }             }         }     } }   2 is prime number 3 is prime number 5 is prime number 7 is prime number 11 is prime number 13 is prime number 17 is prime number 19 is prime number 23 is prime number 29 is prime number   References   Eratothenes - wikipedia  ","categories": ["Algorithm"],
        "tags": ["Data Structure","Mathematics"],
        "url": "http://localhost:4000/algorithm/eratosthenes-sieve/",
        "teaser":null},{
        "title": "합병 정렬(Merge Sort)",
        "excerpt":"Merge Sort(합병 정렬)   합병 정렬 또는 병합 정렬(merge sort)은 O(n log n) 비교 기반 정렬 알고리즘입니다.  일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나입니다. 존 폰 노이만이 1945년에 개발했습니다.     Algorithm   밑의 애니메이션을 먼저 보시고 알고리즘을 읽으시면 이해가 빠를 수 있습니다.      리스트의 길이가 1 이하이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는   분할(divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.   정복(conquer) : 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.   결합(combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 이때 정렬 결과가 임시배열에 저장된다.   복사(copy) : 임시 배열에 저장된 결과를 원래 배열에 복사한다.      Analysis      Note: 7개의 원소가 들어있는 배열에 재귀적 병합 정렬을 적용했을 때 우리가 상상할 수 있는 그림입니다.  배열의 원소가 1개가 될 때까지 원래 배열의 1/2씩 분할을 계속 진행합니다.  배열의 원소가 1개가 되면 병합을 진행합니다.  [38][27]  38은 27보다 크므로 두 원소가 스왑되어 합병됩니다.  [43][3]  43은 3보다 크므로 두 원소가 스왑되어 합병됩니다.  [27, 38] [3, 43]  27과 3이 스왑되고 38과 43은 그대로 배열에 들어갑니다.  이와 마찬가지로 다른 분할 배열들도 위와 같이 진행됩니다.   Java로 구현 - 재귀적(Top-down, Recursive)   설명: 재귀적으로 서브배열의 크기가 1이 될 때까지 계속 분할을 진행합니다.  분할된 배열들을 정렬하고 합병합니다.  // @author lemidia public class MergeSort {     static void divide(int data[], int p, int r){         if(p &lt; r){             int q = (p+r)/2; // Middle             divide(data, p, q); // Left             divide(data, q+1, r); // Right             merge(data, p, q, r); // Merge         }     }      static void merge(int data[], int p, int q, int r){         int i = p; int j = q+1; int k = p;         int temp[] = new int[data.length];          for (int l = p; l &lt; r+1 ; l++) {             if (i &lt;= q &amp;&amp; (j &gt; r || data[i] &lt; data[j])){                 temp[k++] = data[i++];             }else                 temp[k++] = data[j++];         }         for(int l = p; l &lt;= r; l++){             data[l] = temp[l];         }          /*         while (i&lt;=q &amp;&amp; j&lt;=r){             if(data[i] &lt;= data[j]){                 temp[k++] = data[i++];             }else{                 temp[k++] = data[j++];             }         }         while (i&lt;=q)             temp[k++] = data[i++];         while (j&lt;=r)             temp[k++] = data[j++];         for(int l = p; l&lt;=r; l++){             data[l] = temp[l];         }         */      }      public static void main(String[] args) {         int limit = 10;         int arr[] = new int[limit];          for(int i = limit-1; i &gt;= 0; --i){             arr[i] = limit-i;         }         divide(arr, 0, limit-1);         for (int i = 0; i &lt; arr.length; i++) {             System.out.print(arr[i] + \" \");         }     } }   1 2 3 4 5 6 7 8 9 10    시간복잡도  최악 시간복잡도\tO(n log n) 최선 시간복잡도\tO(n log n) 평균 시간복잡도\t일반적으로, O(n log n)  쉬운 설명: 배열의 원소가 n개일 때 깊이는 log(n)만큼 진행 됩니다. (매번 2개씩 분할 되므로)  각 깊이마다 n개의 원소들이 제자리를 찾아 스왑됩니다.  그래서 시간복잡도는 깊이 * n개의 원소 즉, nlog(n)이 됩니다.   References   Merge Sort - wikipedia  ","categories": ["Algorithm"],
        "tags": ["Sort","Mathematics"],
        "url": "http://localhost:4000/algorithm/merge-sort/",
        "teaser":"http://localhost:4000/assets/images/merge-sort-rec.png"},{
        "title": "비선형 구조와 탐색(Non-linear Structure and Search)",
        "excerpt":"비선형 구조와 탐색   비선형 구조란 i번째 원소를 탐색한 다음 그 원소와 연결된 다른 원소를 탐색하려고 할 때, 여러 개의 원소가 존재하는 탐색구조를 말한다.   일반적으로 자료가 트리나 그래프로 구성되어 있을 경우를 비선형 구조라 하고 이러한 트리나 그래프의 모든 정점을 탐색하는 것을 비선형 탐색이라고 이해하면 된다.   비선형 구조는 선형과 달리 자료가 순차적으로 구성되어 있지 않으므로 단순히 반복문을 이용하여 탐색하기에는 어려움이 있다. 그러므로 비선형구조는 스택이나 큐와 같은 자료구 조를 활용하여 탐색하는 것이 일반적이다.   비선형 구조의 탐색은 크게 깊이우선탐색(depth first search, dfs)과 너비우선탐색 (breadth firth search, bfs)으로 나눌 수 있으며, 이 두 가지 탐색법에 대해서 알아본다.   비선형 구조   비선형 구조의 탐색을 다루기 전에 그래프와 트리에 대해서 간단히 알아보자.  트리와 그래프를 이루는 기본 요소를 정점(vertex)과 간선(edge)이라고 한다.      원은 정점, 선분은 간선을 나타내며, a-b는 보통간선, a-&gt;b는 방향간선, b-d는 가중치가 15인 양방향통행 간선, d-&gt;e는 가중치가 7인 일방통행 간선(방향간선)을 나타낸다.  정점은 점 또는 원으로 표현하며, 일반적으로 상태나 위치를 표현한다. 간선은 정점들을 연결하는 선으로 표현하며, 정점들 간의 관계를 표현한다.   경로(path)와 회로(cycle)   그래프에서 임의의 정점 s에서 임의의 정점 t로 이동할 때, s에서 t로 이동하는데 사용한 정점들을 연결하고 있는 간선들의 순서로 된 집합을 경로라고 한다. 회로는 그래프에서 임 의의 정점 s에서 같은 정점 s로의 경로들을 말한다.      자기간선(loop)과 다중간선(multi edge)   임의의 정점에서 자기 자신으로 연결하고 있는 간선을 자기간선, 임의의 정점에서 다른 정점으로 연결된 간선의 수가 2개 이상일 경우를 다중간선이라고 한다.      그래프의 차수(degree)  그래프의 임의의 한 정점에서 다른 정점으로 연결된 간선의 수를 차수라고 한다.      그래프의 구현   그래프를 구현하는 방법은 인접행렬(adjacency matrix)과 인접리스트(adjacency list)로 크게 나눌 수 있다.   tip: 프로그래밍 대회에서 그래프는 보통 정점의 수, 간선의 수, 각 간선들이 연결하고 있는 정점 2개로 이루어진 정보가 주어진다.   다음과 같은 그래프가 주어질 때, 이를 표현하는 2가지 방법을 알아본다.      위 그래프의 입력 형식과 입력 데이터의 예   입력 형식: 첫 번째 줄에 정점의 수 n과 간선의 수 m 이 공백으로 구분되어 입력된다. 두 번째 줄부터 m개의 줄에 걸쳐서 간선으로 연결된 두 정점의 번호와 가중치가   공백으로 구분되어 입력된다.  입력 데이터: 7 11 1 2 47  1 3 69  2 4 57  2 5 124  3 4 37  3 5 59  3 6 86  4 6 27  4 7 94  5 7 21  6 7 40   인접행렬의 구현   입력예시를 인접행렬로 받기 위해서는 2차원 배열을 이용한다.  먼저 최대 정점의 수에 맞추어 2차원 배열을 선언하고 각 배열의 칸에 연결된 정보를 저장한다.  앞 그래프를 2차원 행렬을 이용하여 다음과 같이 저장한다.      2차원 행렬을 이용하여 저장하는 소스코드는 다음과 같다. 단 최대 정점의 수는 100개 로 가정한다.   C language #include &lt;stdio.h&gt;  int n, m, G[101][101]; int main() {     scanf(\"%d %d\",&amp;n,&amp;m);     for(int i=0; i&lt;m; i++) {         int a, b, w;         scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;w);         G[a][b]=G[b][a]=w;     }  }   인접리스트의 구현   인접행렬로 표현할 때에는 연결되지 않았던 부분까지 모두 표현이 된다. 즉, 각 칸에 0 이라고 기록된 부분은 연결이 되지 않은 부분을 의미한다. 사실 일반적인 그래프에서 행렬 상에서 0이라고 표현되는 부분이 많을 가능성이 크다.   알고리즘을 구현할 때에도 이 0이라고 표시된 부분까지 모두 조사를 해야 하므로 효율 이 떨어지는 경우가 많다. 이러한 단점을 극복하기 위하여 제안된 방법이 인접리스트이고 이 방법은 인접행렬에서 0으로 표시된 부분은 저장하지 않으므로 효율을 높이고 있다.         위의 입력 예시를 인접리스트로 구현하기 위해서는 [그림-10], [그림-11]과 같이 연결리스트로 구현할 수 있지만 STL에서 제공하는 C++의 std::vector()를 이용하면 보다 더 간단하게 구현할 수 있다. 위의 입력예시를 인접리스트로 구현하면 다음과 같은 그림이 된다.      C++의 std::vector()를 이용한다면 위와 같이 인접행렬로 구현하는 것보다 공간을 더 적게 사용한다. 따라서 전체탐색법을 구현할 때, 당연히 탐색시간도 줄일 수 있다. 계산량으로 표현하자면, 인접행렬로 모든 정점을 탐색하는데 O($n^2$)의 시간이 드는데 반해, 인접리스트로 표현하면 O(n+m)의 시간이 든다.   여러 가지 장점으로 인해 인접리스트를 이용한 방법을 활용하는 경우가 많으므로 반드시 익혀둘 수 있도록 하자.   비선형 구조의 탐색   깊이우선탐색(dfs)   그래프 중 회로(cycle)가 없는 그래프를 트리라고 한다. 다음 그림은 트리를 나타낸다. 이 트리의 가장 위에 있는 정점에서 출발하여 모든 정점들을 깊이우선으로 탐색하며, 탐색 하는 순서를 알아보자.      출발 정점을 트리의 가장 위에 있는 정점으로 하고, 한 정점에서 이동 가능한 정점이 여 러 개 있을 경우 왼쪽의 정점부터 방문한다고 가정하면, 단계별 탐색 과정은 다음과 같다.      깊이우선탐색과정에서 3단계 이후 더 이상 진행할 수 있는 정점이 없다. 그 이유는 간선 으로 연결된 정점들 중 아직 방문하지 않은 정점을 방문하기 때문이다.   이처럼 더 이상 진행할 수 없을 때는 다시 이전 정점으로 되돌아가는 과정이 필요하다. 일반적으로 이 과정을 백트랙(backtrack)이라고 한다. 백트랙은 비선형 구조의 탐색에서 매 우 중요하다. 백트랙은 스택(stack)이나 재귀함수(recursion)를 이용하면 쉽게 구현할 수 있다.      4, 5, 6단계는 연속으로 백트랙이 발생한다. 이는 더 이상 진행할 수 없는 정점까지 도달 했다는 것을 의미한다. 계속 해서 다음 단계로 진행하는 과정은 다음과 같다.      위 단계에서 마지막 정점을 방문하면 깊이우선탐색이 완료된다.      깊이우선탐색을 정리하여 설명하면 먼저 시작 정점에서 간선을 하나 선택하여 진행할 수 있을 때까지 진행하고 더 이상 진행할 수 없다면 백트랙하여 다시 다른 정점으로 진행 하여 더 이상 진행할 정점이 없을 때까지 이 과정을 반복하는 탐색법으로, 간선으로 연결 된 모든 정점을 방문할 수 있는 탐색법이다.   깊이우선탐색의 알고리즘은 다음과 같다. 이 탐색법은 백트래킹(backtracking)이라는 알 고리즘 설계 기법의 중심이 되며 백트래킹 기법은 모든 문제를 해결할 수 있는 가장 기본 적인 방법이므로 꼭 익혀둘 필요가 있다.   깊이우선탐색   bool visited[101]; //방문했는지 체크해 두는 배열 void dfs(int k){     for(int i=0; i&lt;G[i].size(); i++){ // 정점 k와 연결된 모든 정점 방문         if(!visited[G[k][i].to]){ // 만약 아직 방문하지 않았으면             visited[G[k][i].to]=true; // 방문했다고 체크하고             // 깊이우선탐색 진행             dfs(G[k][i]);         }     }     return; //더 이상 갈 길이 없으면 backtrack }   이 방법은 그래프를 인접리스트에 저장했을 경우에 활용할 수 있다. 전체를 탐색하는데 있어서 반복문의 실행횟수는 모두 m 번이 된다. 일반적으로 인접행렬 보다 속도가 더 빠르기 때문에 자주 활용된다.     너비우선탐색(bfs)   너비우선탐색은 깊이우선탐색과는 달리 현재 정점에서 깊이가 1인 정점을 모두 탐색한 뒤 깊이를 늘려가는 방식이다. 위에서 다룬 ‘10개의 정점과 9개의 간선을 가진 트리’를 통해서 너비우선탐색을 살펴보자.      먼저 1단계부터 4단계까지를 살펴보면 1에서 출발하여 깊이가 1인 세 정점을 모 두 순차적으로 방문한다. 계속해서 너비우선탐색의 결과를 살펴보면 다음과 같다.         너비우선탐색은 백트랙을 하지 않는다. 대신에 현재 정점에서 깊이가 1인 정점을 모두 방문해야 하므로 큐(queue)라는 선입선출(FIFO) 자료구조를 활용하여 현재 정점에서 깊이가 1 더 깊은 모든 정점을 순차적으로 큐에 저장하여 탐색에 활용한다.  따라서 STL에서 제 공하는 std::queue()를 활용하는 방법을 익힐 필요가 있다.   너비우선탐색 알고리즘은 다음과 같다.   #include &lt;queue&gt; bool visited[101]; void bfs(int k){     std::queue&lt;int&gt; Q;     Q.push(k), visited[k]=1;     while(!Q.empty()){         int current=Q.front();         Q.pop();         for(int i=0; i&lt;G[current].size(); i++){             if(!visited[G[current][i]]) {                 visited[G[current][i]]=1;                 Q.push(G[current][i]);             }         }     } }   이 방법은 그래프를 인접리스트에 저장했을 경우에 활용할 수 있으며, 전체를 탐색하는 데 있어서 반복문의 실행횟수는 모두 m번이 된다. 따라서 일반적으로 속도가 인접행렬 보다 더 빠르기 때문에 자주 활용된다.   References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["DFS","BFS","Data structure","programming"],
        "url": "http://localhost:4000/algorithm/%EB%B9%84%EC%84%A0%ED%98%95%EA%B5%AC%EC%A1%B0%EC%9D%98-%ED%83%90%EC%83%89/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm1.png"},{
        "title": "전체탐색법(Brute force)",
        "excerpt":"전체탐색법   전체탐색법은 모든 문제해결의 기초가 되는 가장 중요한 설계법 중 하나라고 할 수 있다. 주어진 문제에서 해가 될 수 있는 모든 가능성을 검사하여 해를 구하기 때문에 항상 정 확한 해를 구할 수 있다는 점이 장점이다. 하지만 탐색해야할 내용이 너무 많으면 문제에서 제시한 시간 이내에 해결할 수 없다는 점을 유의해야 한다.   하지만 전체탐색을 기반으로 한 다양한 응용들이 있으며, 이러한 응용들을 통하여 탐색 해야할 공간을 배제해 나가면서 시간을 줄일 수 있는 다양한 방법들이 존재하기 때문에 잘 응용하면 많은 문제를 해결할 수 있는 강력한 도구가 될 수 있다. 따라서 전체탐색법을 잘 익혀두면 다른 알고리즘 설계법을 학습하는데 많은 도움이 된다.   전체탐색법은 선형구조의 탐색, 비선형구조의 탐색을 기반으로 하여 문제를 해결한다.   선형구조와 비선형구조의 전체탐색   선형구조의 전체탐색은 반복문을 이용하여 접근할 수 있다.  1차 원 뿐만 아니라 2차원 이상의 다차원 구조에 대해서도 선형구조로 탐색할 수 있다.   비선형구조의 전체탐색은 문제해결의 가장 기본이 되는 알고리즘 설계법인 백트래킹을 이용한다.  백트래킹 기법은 재귀함수를 이용하여 간단하게 구현할 수 있고, 다양한 문제를 해결하는데 많이 응용되는 방법이므로 반드시 익혀둘 필요가 있다.   주어진 문제들을 통하여 선형구조, 비선형구조의 전체탐색법을 익힐 수 있도록 하자.   선형 구조에서의 전체탐색   약수의 합  한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오.    예를 들어 10의 약수는 1, 2, 5, 10이므로 이 값들의 합인 18이 10의 약수의 합이 된다.    입력   첫 번째 줄에 정수 n이 입력된다. (단, 1 &lt;= n &lt;= 100,000)    출력   n의 약수의 합을 출력한다. ------------------- 입력 예 10  출력 예 18   이 문제는 기본적으로 수학적인 아이디어를 이용하여 해결할 수 있는 문제이지만 이 단 원에서는 전체탐색법을 다루는 단원이므로 전체탐색법으로 해결해보자.   일단 n을 입력받으면 1부터 n까지의 모든 수를 차례로 반복문을 이용하여 선형으로 탐색하면서 n의 약수들을 검사한다. 만약 현재 탐색 중인 수가 n의 약수라면 누적하여 구 할 수 있다. 이렇게 구한다면 계산량은 O(n)이 된다. 이 문제에서는 n의 최댓값이 100,000이므로 충분히 해결할 수 있는 문제가 된다.   어떤 수 x가 n의 약수라면 다음 조건을 이용해 구할 수 있다.   n % x == 0   이를 이용하여 문제를 해결한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int n; int solve() {     int ans=0;     for(int i=1; i&lt;=n; i++ )         if(n%i==0)             ans+=i;     return ans; }  int main() {     scanf(\"%d\", &amp;n);     printf(\"%d\\n\", solve()); }   이문제는 이와 같은 방법으로 쉽게 해결할 수 있으나, n이 10억 이상의 값으로 커질 때는 다른 방법을 생각해야 한다.  아마 다른 포스트에서 다루게 될 것이므로 한 번 생각해보자.   최댓값  다음과 같이 9×9 격자판에 쓰여진 81개의 자연수가 주어질 때, 이들 중 최댓 값을 찾고   그 최댓값이 몇 행 몇 열에 위치한 수인지 구하는 프로그램을 작성하시오.    예를 들어, 다음과 같이 81개의 수가 주어질 경우에는 이들 중 최댓값은 90이고, 이 값은 5행 7열에 위치한다.    열 1  2  3  4  5  6  7  8  9 행 1    3 23 85 34 17 74 25 52 65 2   10  7 39 42 88 52 14 72 63 3   87 42 18 78 53 45 18 84 53 4   34 28 64 85 12 16 75 36 55 5   21 77 45 35 28 75 90 76  1 6   25 87 65 15 28 11 37 28 74 7   65 27 75 41  7 89 78 64 39 8   47 47 70 45 23 65  3 41 44 9   87 13 82 38 31 12 29 29 80  입력   첫째 줄부터 아홉째 줄까지 한 줄에 아홉 개씩 자연수가 주어진다. 주어지는 자연 수는 100보다 작다.  출력   첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 위치한 행 번호와 열 번호를 빈칸을 사이에 두고 차례로 출력한다.   최댓값이 두 개 이상인 경우 그 중 한 곳의 위치를 출력한다. ---------------------------- 입력 예   3 23 85 34 17 74 25 52 65 10 7 39 42 88 52 14 72 63 87 42 18 78 53 45 18 84 53 34 28 64 85 12 16 75 36 55 21 77 45 35 28 75 90 76 1 25 87 65 15 28 11 37 28 74 65 27 75 41 7 89 78 64 39 47 47 70 45 23 65 3 41 44 87 13 82 38 31 12 29 29 80  출력 예 90 57    이 문제는 2차원 구조를 선형으로 모두 탐색하면 쉽게 해결할 수 있는 문제이다.  2차원 구조는 행 우선으로 탐색하는 방법과 열 우선으로 탐색하는 방법이 있는데, 이 문제는 어떤 방법으로 탐색해도 관계없으며, 일반적으로는 행 우선 탐색을 많이 사용한다.   다음은 행 우선을 반복문으로 구현한 소스코드이다.   for(int row=0; row&lt;5; row++) {     for(int col=0; col&lt;4; col++)         printf(\"[%d, %d]\", row, col);     uts(\"\"); }   이제 문제를 해결하는 방법에 대해서 알아보자.   탐색하기 전 먼저 해를 저장할 변수인 ans를 0으로 초기화한다. 여기서 주의할 점은 각 원소들 중 음수값이 존재할 경우 최댓값을 구하기 위해 ans를 0으로 초기화하면 안 된다는 점이다. 이 문제는 음수값이 존재하지 않기 때문에 ans를 0으로 초기화하고 문제를 해결한다.   참고로 어떤 변수에 값을 초기화하는 몇 가지 방법을 소개한다. 일단 int형의 최댓값은 0x7fffffff(2,147,483,647)이며, 최솟값은 0x80000000(-2,147,483,648)이다. 엄밀하게 최대, 최소를 지정할 때 이 값을 이용하면 되며, 16진법을 이용하면 쉽게 처리할 수 있다.   여기서 주의할 점은 위 값들을 설정한 후 값을 증가시키거나 감소시키면 오버플로 (overflow)로 인하여 답이 잘못될 수 있다.  예를 들어 다음 명령을 보자.   int max = 0x7fffffff; max=max+1;   위 예의 경우에 max값이 최댓값이었는데, 여기서 1을 증가하면 오버플로가 발생하 여 max값은 음수가 된다.  따라서 이런 점을 방지하기 위하여 적어도 2배 정도라 하더 라도 오버플로가 발생하지 않도록 처리하는 경우가 많다.  이럴 때는 주로 최댓값을 987654321 등의 자릿수도 쉽게 알 수 있고 2배를 하더라도 정수 범위에 있는 수 등을 활용하는 경우가 많다.  문제에 따라서는 탐색하고자 하는 데이터 중에서 임의의 한 값 을 최댓값 또는 최솟값으로 결정하는 방법도 있다.   위 문제를 해결하는 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int A[10][10], ans, mi, mj; void input() {     for(int i=0; i&lt;9; i++)         for(int j=0; j&lt;9; j++)         scanf(\"%d\", &amp;A[i][j]); } int solve() {     for(int i=0; i&lt;9; i++)         for(int j=0; j&lt;9 ; j++)             if(ans &lt; A[i][j]) {                 ans=A[i][j];                 mi=i+1; mj=j+1;             } } int main() {     input();     solve();     printf(\"%d\\n%d %d\\n\", ans, mi, mj);     return 0; }   가장 일반적으로 해결할 수 있는 방법이고 이 경우 계산량은 O(row x column)이 된다.  이를 보다 효율적으로 바꾸기 위해서, 입력받으면서 바로 처리할 수도 있으며, ans, mi, mj를 모 두 쓰지 않고 mi, mj만 가지고 처리하는 방법을 소개한다.   #include &lt;stdio.h&gt; int A[10][10], mi, mj; void input_solve() {     for(int i=0; i&lt;9; i++)         for(int j=0; j&lt;9; j++) {             scanf(\"%d\", &amp;A[i][j]);             if(A[mi][mj]&lt;A[i][j])                 mi=i, mj=j;         } } int main() {     printf(\"%d\\n%d %d\\n\", A[mi][mj], mi+1, mj+1);     return 0; }   고기잡이   우리나라 최고의 어부 정올이가 이번에 네모네모 배 고기잡이 대회에 참가한다.    이 대회에는 3개의 라운드가 있는데, 첫 번째 라운드는 1차원 형태로 표현될 수 있는 작은 연못에서 길쭉한 그물을 던져서 최대한 많은 고기를 잡는 것이 목적이다.    1라운드의 예를 들면 연못의 크기가 1*6이고 물고기의 위치와 가치가 다음과 같다고 하자.    1 0 2 0 4 3  여기서 그물의 크기는 1*3이라고 할 때, 잡을 수 있는 방법은 (1 0 2), (0 2 0), (2 0 4), (0 4 3)의 4가지 방법이 있다.    이 중 가장 이득을 보는 방법은 마지막 방법 0 + 4 + 3 = 7이다. 따라서 주어진 경우의 최대 이득은 7이 된다. 정올이는 최대한 가치가 큰 물고기를 잡아서 우승하고 싶어 한다.    연못의 폭과 각 칸에 있는 물고기의 가치, 그물의 가로의 길이와 세로의 길이가 주어질 때, 잡을 수 있는 물고기의 최대이득을 구하는 프로그램을 작성하시오.    입력 첫 번째 줄에 연못의 폭 N이 입력된다. ( N &lt;= 100 인 자연수 ) 두 번째 줄에 그물의 폭 W가 입력된다. ( W &lt;= N 인 자연수 ) 세 번째 줄 W개의 물고기의 가치가 공백으로 구분되어 주어진다. 각 물고기의 가 치는 7이하의 자연수이다. 0일 경우에는 물고기가 없다는 의미이다.  출력 잡을 수 있는 물고기의 최대 가치를 출력한다. --------------------------------- 입력 예 6 3 1 0 2 0 4 3   출력 예 7   이 문제는 전체탐색법을 이용하여 간단하게 해결할 수 있다.  폭이 n인 연못에서 폭이 w인 그물을 던졌을 때 최대 이득을 얻을 수 있는 구간을 찾는 문제이다.  가장 단순한 방 법으로 n개의 주어진 수들 중 연속된 w개의 수들을 탐색하여 합을 구한 다음 최댓값을 갱신하는 방법으로 접근할 수 있다.  먼저 첫 번째 데이터부터 탐색하여 w개의 합을 구한 다음 최댓값을 갱신하고, 두 번째 데이터부터 탐색하여 w개의 합을 구하여 최댓값을 갱신한다. 이런 방법으로 모든 구간을 전체탐색법으로 확인할 수 있다.   입출력 예의 경우 다음과 같은 과정으로 해를 구해나간다.      위의 과정을 보면 탐색을 시작하는 지점이 0번으로부터 시작하여 1씩 증가하는 것을 알 수 있으며, 시작점을 지정하면 그물의 폭인 w만큼 탐색을 진행한다. 따라서 마지막 탐색 의 시작 지점은 n - w + 1 이 된다. 핵심 탐색 부분을 구현하면 다음과 같다.   for(int i=0; i&lt;N‐W+1; i++) {     for(int j=0; j&lt;W; j++)         printf(\"%d \", i+j);     puts(\"\"); }   n = 8 이고 w = 5 일 때, 위 탐색방법의 출력결과는 결과는 다음과 같다.   0 1 2 3 4 1 2 3 4 5 2 3 4 5 6 3 4 5 6 7   즉, [0, 4] 구간, [1, 5]구간, [2, 6]구간, [3, 7]구간으로 모두 4번을 검사한다.   위 소스코드에서 n - w + 1 을 생각하기 어려운 경우에는 배열을 좀 더 크게 잡은 후 다음과 같이 작성해도 관계없다.   for(int i=0; i&lt;N; i++) {     for(int j=0; j&lt;W; j++)         printf(\"%d \", i+j);     puts(\"\"); }   위와 같이 작성하면 생각하기 쉽기 때문에 빠른 시간에 코딩이 가능하다. 위의 코드의 출력결과는 다음과 같다.   0 1 2 3 4 1 2 3 4 5  2 3 4 5 6 3 4 5 6 7 4 5 6 7 8  5 6 7 8 9 6 7 8 9 10  7 8 9 10 11   위의 아이디어 들을 이용하여 문제를 해결한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int data[101], N, W, ans = 0; int main() {     scanf(\"%d%d\", &amp;N, &amp;W);     for(int i=0; i&lt;N; i++)         scanf(\"%d\", data+i);      for(int i=0; i&lt;N+W‐1; i++) {         int sum=0;         for(int j=0; j&lt;W; j++)             sum+=data[i+j];         if(sum&gt;ans) ans=sum;     }     printf(\"%d\", ans); }   이 알고리즘의 계산량은 1~N의 각 위치에 대해서 W만큼 탐색을 하므로 O(NW)가 됨 을 알 수 있다.  문제에서 제시한 N의 최대치가 100,000이 입력되고 그물의 크기가 적당히 크면 수행시 간이 많이 걸리므로 좀 더 효율적인 알고리즘이 필요하다.   비선형 구조에서의 전체탐색   계단 오르기   길동이는 n개의 단으로 구성된 계단을 오르려고 한다.   길동이는 계단을 오를 때 기분에 따라서 한 번에 1단 또는 2단을 올라갈 수 있다.   계단의 크기 n이 주어질 때, 길동이가 이 계단을 올라갈 수 있는 모든 경우의 수를   구하는 프로그램을 작성하시오.    만약 계단이 3개라면 길동이는 1, 1, 1로 올라가는 법과 1, 2로 올라가는 법, 2, 1로  올라가는 법의 3가지 서로 다른 방법이 있다.   ----------------------------------------- 입력 계단의 수 n이 입력된다(단 n은 20보다 작은 자연수).    출력 길동이가 계단을 오르는 모든 방법의 수를 출력한다.  입력 예         출력 예 3              3     이 문제도 비선형구조로 전체탐색을 하여 해를 구할 수 있다.  현재 상태에서 1칸 또는 2 칸을 올라갈 수 있으므로, 탐색구조를 다음과 같이 설정할 수 있다.   단, 주의할 점은 정확 하게 n칸에 도착했을 때만 한 가지 경우로 처리해야한다는 점이다.  예를 들어 도착점까지 한 칸 남았을 경우에는 2칸을 올라갈 수 없다.      위의 탐색 과정으로 5칸의 계단을 오르는 과정을 보면 다음과 같다.      위와 같은 트리를 구성하면서 전체탐색을 하면 n은 5일 때, 방법은 8임을 알 수 있다.  이와 같은 구조의 탐색을 소스코드로 구현하면 다음과 같다.   #include &lt;stdio.h&gt; int n, ans; void solve(int v) {     if(v&gt;n) return; // --- (a)     if(v==n){ // 현재 n칸이면          ans++;         return;     }     solve(v+1); // 1칸 오르기     solve(v+2); // 2칸 오르기 } int main() {     scanf(\"%d\", &amp;n);      solve(0);      printf(\"%d\\n\", ans); }   Warning: (a)행의 조건은 마지막 계단을 넘어가는 경우를 처리한다. 이 구문이 없으면 무한 재귀에 빠지게 된다.   거스름 돈   여러분은 실력을 인정받아 전 세계적으로 사용할 수 있는 자동판매기용 프로그램의   개발을 의뢰받았다. 거스름돈에 사용될 동전의 수를 최소화하는 것이다.   입력으로 거슬러 줘야할 돈의 액수와 그 나라에서 이용하는 동전의 가짓수   그리고 동전의 종류가 들어오면 여러 가지 방법들 중 가장 적은 동전의 수를 구하는   프로그램을 작성하시오.  ----------------------------------------- 입력 첫 번째 줄에는 거슬러 줘야할 돈의 액수 m이 입력된다.   ( 10 &lt;= m &lt;= 10,000 )   다음 줄에는 그 나라에서 사용되는 동전의 종류의 수 n이 입력된다.   ( 1 &lt;= n &lt;= 10 )   마지막 줄에는 동전의 수만큼의 동전 액수가 오름차순으로 입력된다.   ( 10 &lt;= 액수 &lt;= m )    출력 최소의 동전의 수를 출력한다.    입력 예 730 5 10 50 100 500 1250  출력 예 6   이 문제는 매우 잘 알려진 유명한 문제 중 하나로 다양한 방법으로 해결할 수 있는 대표적인 문제이다. 이 단원에서는 전체탐색법을 기반으로 하여 해결하는 방법에 대해서 소개한다. 대부분의 문제들에서도 마찬가지지만 문제를 전체탐색으로 구조화하는 방법에 따라 해법의 계산량이 달라질 수 있다.   이 문제에서는 2가지 서로 다른 구조화로 해결하는 방법을 소개한다. 먼저 첫 번째 방법은 문제의 상태를 지금까지 지불한 액수로 설정하고, 서로 다른 동전 1개를 이용하여 지불하는 경우를 간선으로 생각할 수 있다.   이 방법으로 구조화하는 방법은 다음 그림과 같다. 이 때 $x$의 값은 지금까지 지불한 액수이며 사용 가능한 동전은 4가지 종류로 10원, 50원, 100원, 500원일 때를 가정한 것이다.      처음에 0원으로 출발하여 각 동전을 지불해 나가며, 지불할 금액과 일치할 때의 깊이가 지불한 동전의 개수이므로, 지불할 금액과 일치하는 최소 깊이를 구하는 문제가 된다. 만약 지불할 금액과 일치했거나 금액을 초과했을 경우에는 백트랙하면서 탐색을 진행하도록 코 드를 작성하면 된다.   지불해야할 금액이 120원이고, 사용가능한 동전이 30원, 50원, 60원, 100원일 때의 전체 탐색구조는 다음과 같다. 먼저 처음 깊이 1까지의 구조이다.      다음은 30원 이하의 정점들의 전체적인 구조이다. 파란색 정점은 120원 지불에 성공한 것을 나타낸다.      계속해서 50원과 60원 정점의 전체 탐색구조를 나타낸다. 100원 이하에서는 더 이상의 탐색이 불가능하다.      #include&lt;stdio.h&gt; int m, n, coin[10], ans=987654321; void solve(int mon, int d) {     if(mon&gt;m) return;     if(mon==m){         if(d&lt;ans) ans=d;          return;     }     for(int i=0; i&lt;n; i++)         solve( mon+coin[i], d+1 ); } int main() {     scanf(\"%d %d\", &amp;m, &amp;n);     for(int i=0; i&lt;n ; i++ )         scanf(\"%d\", coin+i);      solve(0, 0);      printf(\"%d\\n\", ans);      return 0; }   위 프로그램에서의 solve()함수는 다음과 같은 상태를 표현하고 있다.   solve(mon, d) = “d개의 동전으로 mon원을 사용한 상태”   이 방법은 정확하게 해를 구할 수는 있으나 이론상으로 최대 금액이 10,000원이고 최소 액수가 10원이므로 최대 깊이가 1,000까지 갈 수 있기 때문에 시간 내에 해결할 수 없다.   시간을 줄이기 위한 다양한 방법이 있지만, 이번에는 다른 구조를 이용하여 해결할 수 있는 방법을 소개한다. 탐색구조를 어떻게 설계하느냐에 따라서 해법의 계산량이 달라질 수 있다는 것을 알고, 문제를 해결할 때, 탐색구조를 어떻게 구성해야하는지 먼저 고민하는 것이 중요하다.   이번에 소개하는 구조는 이전과는 달리 같은 깊이에서는 같은 동전으로만 지불하는 방법으로 구조를 구성한다. 한 깊이에서 간선의 수는 해당 깊이의 동전을 0개로부터 해당 금액을 최대한 지불할 수 있는 최대한의 수로 설정하여 진행한다. 다음 그림을 통하여 자세 히 알아보자. 동전은 30원, 50원, 60원, 100원이다.      실제 지불할 금액은 120원, 지불가능한 동전의 수는 50원, 60원, 100원일 때의 경우 전체 구조는 다음과 같다.      이 방법으로 구현한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int n, m, coin[10], ans=987654321; void solve(int mon, int k, int cnt) {      if(mon==m){         if(ans&gt;cnt) ans=cnt;         return; // 백트랙     }     if(k==n) return; // 더 이상 깊이 진행 X, 백트랙     for(int i=0; mon+coin[k]*i&lt;=m; i++) // 조건 만족하지 않을 시 백트랙         solve(mon+coin[k]*i, k+1, cnt+i); } int main() {     scanf(\"%d %d\", &amp;m, &amp;n);      for(int i=0; i&lt;n; i++)          scanf(\"%d\", coin+i);     solve(0, 0, 0);     printf(\"%d\\n\", ans);      return 0; }   위 프로그램에서의 solve()함수는 다음과 같은 상태를 표현하고 있다.   solve(mon, k, cnt )= “k번째 이하의 동전을 cnt개 사용하여 mon원을 거슬러 준 상태”   이 방법은 앞에서 시도했던 방법보다 속도가 획기적으로 빨라진다. 그 이유는 전체 상태를 그려보면 앞의 방법보다 이번에 구조화한 방법의 정점의 수가 훨씬 적기 때문이다. 이와 같이 구조를 어떻게 설계하느냐에 따라 알고리즘의 계산량이 달라지기 때문에, 문제를 해결할 때 먼저 최적의 구조를 설계하는 것이 중요하다.   연구활동 가는 길      *위의 그래프를 참고하여 문제를 풀어보자*  정올이는 GSHS에서 연구활동 교수님을 뵈러 A대학교를 가려고 한다. 출발점과 도착점을 포함하여 경유하는 지역 n개, 한 지역에서 다른 지역으로 가는 방법이 총 m 개이며  GSHS는 지역 1이고 A대학교는 지역 n이라고 할 때 대학까지 최소 비용을 구하시오.  단, n은 10 이하, m은 30 이하, 그리고 한 지역에서 다른 지역으로  가는 데에 필요한 비용은 모두 200 이하 양의 정수이며 한 지역에서 다른 지역으로 가는 어떠한 방법이 존재하면  같은 방법과 비용을 통해 역방향으로 갈 수 있다.  위의 그래프는 예를 보여준다. (단, 정점a-&gt;정점b로의 간선이 여러 개 있을 수 있으 며, 자기 자신으로 가는 정점을 가질 수도 있다.)  최소 비용이 드는 경로 : 1→3→5→7, 최소 비용 : 69+59+21=149  입력 첫 번째 줄에는 정점의 수 n과 간선의 수 m이 공백으로 구분되어 입력된다. 다음 줄부터 m개의 줄에 걸쳐서 두 정점의 번호와 가중치가 입력된다. (자기 간선, 멀티 간선이 있을 수 있다.)  출력 대학까지 가는 데 드는 최소 비용을 출력한다. 만약 갈 수 없다면 “-1”을 출력.  ---------------------------- 입력 예  7 11 1 2 47 1 3 69 2 4 57 2 5 124 3 4 37 3 5 59 3 6 86 4 6 27 4 7 94 5 7 21 6 7 40  출력 예 149    이 문제는 그래프 상의 최단경로를 구하는 매우 유명한 문제이다.  이 문제를 해결하는 알고리즘은 여러가지가 알려져 있지만, 어려운 알고리즘을 모르더라도 전체탐색법을 통하여 해결할 수 있다.   이 문제는 그래프 구조이므로 비선형탐색법으로 해를 구할 수 있다.  먼저 출발정점에서 깊이우선탐색을 이용하여 출발점으로부터 도착점까지 가능한 모든 경로에 대해서 구해본다.   하나의 경로를 구할 때마다 해를 갱신하면서 최종적으로 가장 적합한 해를 출력한다.  주어진 예를 통하여 전체탐색하는 과정을 간단하게 살펴보자.            Warning:  중간에 몇개의 과정이 생략되었음에 유의      따라서 위의 경우 전체탐색법으로 탐색한 결과 최소 이동거리는 149가 됨을 알 수 있다.  위의 과정과 같은 방법으로 코딩한 결과는 다음과 같다.   #include&lt;stdio.h&gt; int n, m, G[11][11], sol = 0x7fffffff, chk[11]; void solve(int V, int W) {     if(V==n){ // 도착 여부를 확인하여 현재 정점이 도착점이라면         if(W&lt;sol) sol=W; // 더 좋은 해가 있으면 해를 갱신             return; // 백트랙     }     for(int i=1; i&lt;=n; i++)         if(!chk[i] &amp;&amp; G[V][i]) {             chk[i]=1; // 다음 정점으로 진행할 때 다음 방문할 정점을 체크             solve(i, W+G[V][i]); // 다음 정점으로 진행             chk[i]=0; // 백트랙해서 돌아오면 체크를 해제         } }  int main(void) {     scanf(\"%d %d\", &amp;n, &amp;m);     for(int i=0; i&lt;m; i++) {         int s,e,w;         scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);         G[s][e]=G[e][s]=w;     }     solve(1, 0);     printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);     return 0; }   이 문제의 경우 정점과 간선의 수가 많지 않으므로 인접행렬로도 충분히 처리가 가능하기 때문에 인접행렬로 처리한다.  solve(a, b)는 현재 a정점까지 방문한 상태로 이동거리가 b라고 정의하고 있으며, chk배 열이 현재까지 방문한 정점들의 정보를 가지고 있다.  다음 정점으로 진행할 때 chk[i]=1 같이 chk배열에 다음 방문할 정점을 체크하고 만약 백트랙해서 돌아온다면, chk[i]=0 같이 체크를 해제하며 전체탐색을 진행한다.   if(V==n) 부분에서 도착 여부를 확인하여 현재 정점이 도착점이라면, 지금까지의 이동 거리와 현재 까지 구한 해를 비교하여 더 좋은 해가 있으면 해를 갱신한다. 이와 같이 작성할 경우 도시의 수가 n개라고 할 때 O(n!)의 계산이 필요하다.   후에 다른 포스트에서 탐색배제를 이용하여 계산복잡도를 향상해본다.   References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["DFS","BFS","Data structure","programming","Brute force"],
        "url": "http://localhost:4000/algorithm/%EC%A0%84%EC%B2%B4%ED%83%90%EC%83%89%EB%B2%95/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm25.png"},{
        "title": "탐색공간의 배제(Exclusion of Search Space)",
        "excerpt":"Notice: 이 글은 [전체탐색법]의 후행 내용으로서, 먼저 제 블로그의 전체탐색법을 보시고 이 포스트를 보시는 것을 추천드립니다!   탐색공간의 배제   전체탐색법은 대부분의 경우 해를 구할 수 있는 알고리즘이다. 하지만 실행시간이 너무 길어 제한 시간 내에 문제를 해결할 수 없는 경우가 많다. 탐색공간의 배제는 전체탐색 알고리즘을 구현하는 데 있어서 더 이상 탐색하지 않더라도 해를 구하는 데 문제가 없는 부분을 판단하여 이 부분에 대해서 탐색을 하지 않으므로 탐색의 효율을 높이고자 하는 방법이다.   탐색공간의 배제는 전체탐색에서 불필요한 탐색공간을 탐색하지 않음으로써 알고리즘의 효율을 향상시킨다. 이와 같이 탐색공간을 배제하는 방법은 다양하며 가장 기본 전략은 전체탐색설계와 같이 탐색으로 시작하여 모든 공간을 탐색하는 것이 아니라 일정한 조건을 두어 탐색영역을 배제하는 것이다.   배제되는 탐색공간의 크기에 따라 알고리즘의 성능의 향상 폭이 달라진다. 하지만 잘못 설계를 하여, 해가 있는 상태를 배제하면 해를 구할 수 없는 경우가 발생한다. 따라서 탐색 영역을 배제할 때는 엄밀한 수학적 접근이 필요하다. 이 설계방법은 탐색영역을 배제하는 방법에 따라서 수학적 배제, 경험적 배제, 구조적 배제로 나눌 수 있다.   각 방법에 대해서 자세히 알아보자.   수학적 배제를 이용한 설계   탐색 공간 중 배제할 영역을 수학적 증명으로 결정하는 방법으로는 이분탐색 알고리즘 이 있다. 이는 일종의 수학적 배제를 이용하여 탐색공간을 줄여나가는 알고리즘 설계방법 이라고 할 수 있다.   오름차순으로 정렬된 상태의 이분탐색에서 현재 탐색한 값이 목표하는 값보다 작다면, 현재 탐색 위치의 왼쪽 영역에는 해가 존재할 가능성이 없다. 이는 수학적으로 쉽게 증명 할 수 있다.   따라서 왼쪽 영역에 대해서는 탐색할 필요가 없음을 알 수 있다. 그러므로 다음 탐색영역은 이를 배제하고 오른쪽 영역만 탐색하는 방법이다. 이와 같이 수학적으로 탐색할 필요가 없음이 증명된 공간들을 배제해 나가며 탐색하는 것과 같은 접근법이 수학적 배제를 이 용한 방법이라고 할 수 있다.   수학적 배제로 알고리즘을 설계할 경우, 공간을 배제할 원리를 수학적으로 증명한 후, 이 방법을 반복적으로 해를 찾을 때까지 적용해 나가며 해를 찾는다. 탐색공간에서 선택 배제된 부분은 수학적으로 탐색할 필요가 없으므로, 일반적으로 탐색법이긴 하지만 백트랙 없이 선형으로 진행되는 경우가 많다.   수학적으로 공간을 배제해 나가는 이 방법은 일종의 탐욕법(greedy)이라고 할 수 있으며, 엄밀하게 수학적으로 증명을 하기 때문에 수학적 탐욕법(mathematical greedy)라고 할 수 있다.   하지만 수학적 증명 없이, 직관적으로 현재 상태만으로 잘못된 판단을 하게 되면 올바른 해를 구할 수 없는 가능성을 가지는 단순 탐욕법이 될 수 있으므로 주의해야 한다. 하지만 단순 탐욕법의 경우에도 다양한 응용법이 있으므로 다음에 다루도록 한다.   다음 예는 루트 정점에서 출발하여 각 정점의 값을 누적하며 마지막 정점까지의 합을 최대화하는 최적화문제이다. 이 문제의 목적은 값을 최대화 하는 것이므로 다음 [영역배제의 규칙]을 적용하여 탐색 영역을 배제해 나가보자.   영역배제의 규칙: 현재 상태에서 다음으로 탐색할 수 있는 정점들 중 더 높은 점수가 있는 정점으로 탐색한다.  (즉, 더 작은 점수가 있는 정점의 영역을 배제한다.)   이 규칙은 수학적으로 설득력이 있어 보인다. 왜냐하면 값을 최대화하기 위해서는 작은 값보다는 큰 값이 이득이 되기 때문이다. 하지만 엄밀한 수학적 증명은 하지 않았다. 이 방법으로 탐색을 진행하는 과정은 다음과 같다.      처음 출발점이 루트이므로 루트에 적힌 3점을 획득하여 현재 점수는 3점이다.  다음으로 이동할 수 있는 정점들은 왼쪽 아래로 연결된 8점이 기록된 정점과 오른쪽 아래로 연결된 2점이 기록된 정점의 2가지이다. 이 상태에서 [영역배제의 규칙]을 적용하여 값이 더 큰 8점이 기록된 정점을 선택하고 2점이 기록된 정점을 배제하고 진행한다.      이 규칙을 적용하여 마지막까지 탐색한 결과는 위 그림에서 구한 해는 3-8-4-5를 선택하게 되며 이 때 얻은 점수는 3+8+4+5 이 된다. 과연 20점 이상을 획득할 수 있는 경로는 존재하지 않을까? 다음 그림을 보자.      위 결과를 보면 알 수 있듯이 3+2+9+8=22의 경로가 존재하며 앞 에서 영역을 배제했던 규칙이 잘못됐음을 알 수 있다. 수학적 배제는 엄밀한 수학적 접근 없이, 단순히 직관적으로 배제의 규칙을 결정하면 최적해를 구할 수 있음을 보장할 수 없다. 하지만 구현이 간단하며, 일반적으로 최적해와의 차이가 크지 않은 해를 구할 수 있다는 장점을 이용하여 다른 설계법에 응용할 수 있으므로 나중에 다시 살펴보기로 하자.   주어진 문제들을 통하여 수학적 배제 방법으로 알고리즘을 설계해보자.   약수의 합   한 정수 n을 입력받아서 n의 모든 약수의 합을 구하는 프로그램을 작성하시오.    예를 들어 10의 약수는 1, 2, 5, 10이므로 이 값들의 합인 18이 10의 약수의 합이 된다.    입력   첫 번째 줄에 정수 n이 입력된다. (단, 1 &lt;= n &lt;= 10,000,000,000(100억))    출력   n의 약수의 합을 출력한다. ------------------- 입력 예 10  출력 예 18   이 문제는 전체탐색법 - 약수의 합과 동일한 문제이다. 차이점은 앞의 문제가 입력값의 정의역이 100,000이었던 것에 반해,이 문제에서는 입력값이 100억으로 커졌다는 것이다.   앞의 문제에서 작성했던 풀이는 다음과 같다.   #include &lt;stdio.h&gt; int n; int solve() {     int ans=0;     for(int i=1; i&lt;=n; i++ )         if(n%i==0)             ans+=i;     return ans; }  int main() {     scanf(\"%d\", &amp;n);     printf(\"%d\\n\", solve()); }   이 소스코드는 1부터 n까지의 모든 원소들을 탐색하여, 탐색 대상인 수 i가 n의 약수 라면 취하는 방식으로 진행된다.  따라서 계산량은 O(n)이다.   이번 문제는 n의 최댓값이 100억이므로 이 방법으로는 너무 많은 시간이 걸린다. 따라서 탐색영역을 배제해야 할 필요가 있다.   먼저 간단한 수학적인 원리들을 생각해보자. 먼저 다음 정리를 이용하자.   모든 자연수 n에 대하여 1과 n은 항상 n의 약수이다.  이 원리를 이용하면 위 소스코드의 8행의 탐색범위를 줄여서 다음과 같이 표현할 수 있다.   for(int i=2; i&lt;n; i++)    if(n%i==0)     ans+=i;   원래 소스코드보다 탐색공간이 줄어들긴 했으나 효율을 높이기에는 너무 미미하기 때문에 효율향상을 느낄 수 없다. 하지만 위 아이디어를 조금 응용하면 탐색공간을 많이 줄일 수 있다.   위 아이디어를 응용하기 위해서 다음 원리를 적용할 수 있다.   모든 자연수 n에 대하여, 2이상 n미만의 자연수들중 가장 큰 n의 약수는 n/2를 넘지 않는다.  이 원리를 적용하면 다음과 같이 탐색영역을 줄일 수 있다.   for(int i=2; i&lt;n/2; i++)    if(n%i==0)     ans+=i;   이 알고리즘은 탐색영역이 처음의 소스코드의 반이하로 줄어든 것이다. 따라서 실행시간 은 2배 이상 빨라질 것을 예상할 수 있다.   수학적인 아이디어로 탐색 영역을 반 정도 줄였지만 아직도 매우 큰 입력 값을 처리하기에는 시간이 너무 오래 걸린다. 탐색 공간을 더 배제할 수 있는 아이디어를 생각해보자.   임의의 자연수 n의 약수들 중 두 약수의 곱은 n되는 약수 a와 약수 b는 반드시 존재한 다. 단, n이 완전제곱수일 경우에는 약수 a와 약수 b가 같을 수 있다. 자연수 10의 약수를 통해서 알아보자. 자연수 10의 약수의 개수는 4개이며 다음과 같다.   { 1, 2, 5, 10}   위 집합을 살펴보면 아래와 같은 관계를 찾을 수 있다.        |--| { 1, 2, 5, 10}   |_________|     10의 약수 관계   위 그림에서 알 수 있듯이 1과 10의 곱은 10이고 2와 5의 곱은 10이다. 약수의 개수를 $c$개라고 하고, $d_i$를 $n$의 약수 중 $i$번째 약수라 하면 다음과 같은 식이 성립한다.   Expression: $ n = d_k * d_{c-k+1}$   즉, $k$번째 원소와 $c-k+1$번째 원소의 곱은 항상 $n$이다. 이 원리를 적용하면 10의 약수 를 구할 때, 1과 2만 탐색하면 5와 10을 알 수 있으므로 모든 약수를 구할 수 있다.   단, $n$이 완전제곱수 일 경우에는 약수의 개수가 홀수이므로 $d_k$번째 원소와 $d_{c-k+1}$번째 원소가 같을 경우가 한 건 존재한다. 완전제곱수인 16의 약수를 살펴보자.        |-----| { 1, 2, 4, 8, 16}   |____________|      16의 약수 관계   위 그림에서 알 수 있듯이 완전제곱수인 경우에는 $\\lceil{c\\over2}\\rceil$번째 원소는 짝이 없다.  따라서$d_{\\lceil{c\\over2}\\rceil} * d_{\\lceil{c\\over2}\\rceil} = n$이 된다. 즉 4와 4를 곱하여 16을 만들 수 있다.   이 원리를 적용하면 최악의 경우 2부터 $\\sqrt{n}$까지만 탐색하면 모든 약수를 알 수 있다.   즉 100의 모든 약수를 구하려면 2부터 10까지만 조사해 보면 된다.   {2, 3, 4, 5, 6, 7, 8, 9, 10}   이 수들 중 10의 약수인 것만 찾아보면 다음과 같다.  {2, 4, 5, 10}  위 약수들을 이용하여 짝을 찾아서 정리하면 다음과 같다  {2, 4, 5, 10, 20, 25, 50}   여기에 1과 100은 당연히 100의 약수이므로 문제의 해는 다음과 같다.   1 + 2 + 4 + 5 + 10 + 20 + 25 + 50 + 100 = 217   탐색영역을 [2, $\\sqrt{n}$]로 설정할 때 일반적으로 다음과 같이 프로그램을 작성한다.   // include &lt;math.h&gt; for( i = 1 ; i &lt;= sqrt(n) ; i++ ) // 또는 for(i=1;i*i&lt;=n; i++)   이와 같이 간단한 수학적인 아이디어를 활용하면 효율적인 소스코드를 작성할 수 있으 므로 항상 이런 아이디어를 활용할 수 있도록 익혀두자.   이처럼 탐욕적인 방법을 이용하면 큰 범위의 수도 컴퓨터 없이 쉽게 계산할 수 있다. 그런데 이 방법을 프로그래밍으로 표현하기 위해서 주의할 점이 있다.   입력값 n이 100억 이기 때문에 자료형 int로는 이 값을 처리할 수 없다. 따라서 64bit형 정수인 long long int형을 활용해야 된다. 이 방법을 알고리즘으로 표현하면 다음과 같다.   #include &lt;stdio.h&gt; long long int n; long long int solve() {     long long int i, ans = 0;     for(i=1; i*i&lt;n; i++)       if(n%i==0)         ans+=(i+n/i);      if(i*i==n)        ans += i;     return ans; } int main() {   scanf(\"%lld\", &amp;n);   printf(\"%lld\\n\", solve());   return 0; }   소수 구하기   한 정수 n을 입력받는다. n번째로 큰 소수를 구하여 출력한다. 예를 들어 n이 5라면 자연수들 중 소수는 2, 3, 5, 7, 11, 13, ...이므로 구하고자 하는 5번째 소수는 11 이 된다.  ----------------------------------- 입력 첫 번째 줄에 정수 n이 입력된다.   ( 단, 1 &lt;= n &lt;= 100,000 ) 출력 n 이하의 소수들의 합을 구하여 출력한다.  입력 예         출력 예 5 11          77 389  일반적으로 소수를 구하는 방법은 약수가 2개라는 성질을 이용하는 경우가 많다. 이 성질을 이용하여 임의의 정수 $k$가 소수인지 판단하는 알고리즘을 다음과 같이 만들 수 있다.   bool isPrime(int k) {   int cnt=0;   for(int i=1; i&lt;=k; i++)     if(k%i==0) cnt++;   return cnt==2; }  이 방법은 계산량이 O($n$)이므로 효율이 좋지 않다. 결국 $k$번째 소수를 구하는 알고리즘은 O($nk$)정도의 계산량이 요구되므로 원하는 시간 내에 답을 구하지 못할 가능성이 크다.  효율을 높이기 위해서는 탐색공간의 배제가 필요하다. 어떤 아이디어로 탐색공간을 줄 일 수 있을까?   먼저 위 함수는 소수인지 판단하는 함수이며, 소수가 아니라면 약수가 몇 개이건 합성수인 것은 변함이 없으므로, 약수가 2개를 초과한다면 더 이상 탐색할 필요가 없다. 따라서 다음과 같이 isPrime 함수를 수정하여 탐색공간을 줄일 수 있다.   bool isPrime(int k) {   int cnt=0;   for(int i=1; i&lt;=k; i++) {     if(k%i == 0) cnt++;     if(cnt&gt;2) break;   }   return cnt==2; }   이와 같이 처리하면 대부분의 합성수는 매우 빠른 시간 내에 소수가 아님을 판정할 수 있다. 그리고 위 알고리즘을 다음과 같이 표현해도 된다. 각자 코딩스타일에 맞추어 원하는 방법을 익힐 수 있도록 한다.  bool isPrime(int k) {   int cnt=0;   for(int i=1; i&lt;=k &amp;&amp; cnt&lt;=2; i++) {     if(k%i == 0) cnt++;   }   return cnt==2; }  이번에 소스코드는 3행의 반복문의 반복조건을 바꾸어 처리하고 있다. 이렇게 하여 합성수를 빠르게 검사할 수 있지만 결국은 $k$번째 소수를 찾는 것이 목적이므로 소수를 검사할 때는 여전히 많은 시간이 걸린다.   소수를 보다 빠르게 검사할 수 있는 방법은 무엇일까?   다음 명제를 생각해보자.   임의의 자연수 $n$이 소수라면 $n$의 약수는 1과 n만 존재한다.   위 명제를 조금 변경하면 다음과 같은 원리를 생각할 수 있다.   임의의 자연수 $n$이 소수라면 구간 [2, $n-1$]에서 약수는 존재하지 않는다.   따라서 소수 판정 알고리즘을 다음과 같이 줄일 수 있다.   bool isPrime(int k) {   int cnt=0;   for(int i=2; i&lt;k; i++) {     if(k%i == 0) false;   }   return true; }   이 방법도 합성수는 매우 빠르게 판정할 수 있지만 소수 판정은 시간이 많이 걸리는 단점이 있다.   하지만 이 방법으로부터 소수를 매우 빠르게 판정할 수 있는 방법을 만들 수 있다.   주어진 범위에서 약수가 없어야 하므로, 약수의 존재성만 파악하면 된다. 약수의 존재성을 파악하기 위해서 모든 범위를 검사할 필요는 없다. 앞서 약수 문제에서 다루었던 것과 같이 $n$의 약수를 구하기 위해서 탐색을 $\\sqrt{n}$까지만 탐색하면 된다. 소수판정 에서도 이 원리를 그대로 적용할 수 있다. 이 원리를 적용하여 소수 판정 알고리즘을 완성 하면 다음과 같다.   bool isPrime(int k) {   int cnt=0;   for(int i=2; i*i&lt;=k; i++)     if(k%i == 0) return false;   return true; }   이 알고리즘은 매우 빠른 시간에 소수를 판정할 수 있다. O($\\sqrt{n}$)으로 처리할 수 있다. 이 방법보다 더 빠른 방법이 있다. “에라토스테네스의 체”라는 방법을 이용하 면 더 빠른 시간에 $k$번째 소수를 구할 수 있다. “에라토스테네스의 체”는 다음과 같은 단계를 거쳐 소수를 구한다.   준비. 2부터 n까지 차례로 숫자를 쓰고, 2부터 탐색을 시작한다. 1단계. 현재 탐색 중인 수가 지워지지 않았으면 그 수는 소수이다. 2단계. 1단계에서 그 수가 소수이면 그 수의 배수를 모두 지운다. 3단계. 만약 아직 탐색이 끝나지 않았으면 다음 수를 탐색할 준비를 하고 1단계로 간다. 4단계. 지워지지 않은 모든 수는 소수, 지워진 수는 합성수이다.   이 “에라토스테네스의 체”를 이용해도 빠른 시간에 $k$번째 소수를 구할 수 있다.   다음 포스트를 참고하면 좋다. - 에라토스테네스의 체   경험적 배제를 이용한 설계   경험적 배제는 전체탐색법을 기본으로 한 알고리즘 설계 방법이다. 처음 시작은 전체탐색과 마찬가지로 해가 될 수 있는 모든 공간을 탐색해 나간다. 차이점은 특정 조건을 두고, 이 조건을 기준으로 다음 상태를 계속 탐색할지의 여부를 결정 한다.   여기서의 특정 조건이란, 더 이상 탐색하더라도 해를 구할 수 없음을 판단할 수 있는 조건을 말한다. 이 조건의 설정은 알고리즘이 시작될 때는 정할 수 없고, 탐색을 진행하는 중 에 조건을 설정하고, 탐색한 영역이 넓어질수록 상황에 따라 조건이 갱신된다. 따라서 탐색 한 정보, 즉 경험한 정보를 이용해서 배제할 조건을 정하기 때문에 경험적 배제라고 한다.   경험적 배제는 일반적으로 가지치기(branch &amp; bound)라고 한다. 이는 마치 탐색구조를 나무로 비유하고, 탐색하지 않는 분기에 대해서 자르는 것이 마치 나무를 관리할 때 가치 를 쳐내는 것과 유사하여 붙여진 이름이다.   다음과 같은 탐색구조가 가지는 문제가 있다.      위 구조에서 각 번호는 탐색할 순서이다. 만약 2번에서 3번으로 진행하려고 할 때, 3번 정점이 알고리즘에서 설정한 조건을 만족한다면 3번 정점 이하의 모든 정점들을 더 이상 탐색할 필요가 없으며, 바로 9번으로 진행할 수 있다.      위 그림은 더 이상 필요 없음을 판단한 영역을 배제하고 탐색한 결과를 나타낸다. 이는 결과적으로 11회 탐색해야 할 문제를 6회의 탐색으로 동일한 결과를 얻을 수 있기 때문에 알고리즘의 효율을 향상시킬 수 있다.   일반적으로 더 이상 탐색할 정점이 없어서 되돌아오는 것을 백트랙 or 백트래킹(Backtracking)이라고 한다. 하지만 위의 예와 같이 3번 정점에서 되돌아 온 흐름은 백트랙과는 다르다.  이렇듯 어떤 조건에 의해서 더 탐색할 공간이 있음에도 불구하고 돌아오는 흐름을 바운딩(bounding) 혹은 커팅(cutting)라고 한다.   바운딩은 우리가 공을 벽에 던지면 튕겨 나오는 상태를 말한다. 마치 3번 정점이 벽과 같이서 흐름이 튕기는 것처럼 느껴지기 때문에 바운딩이라는 용어를 쓴다. 이 용어를 이해하면 branch &amp; bound라는 이름의 의미를 알 수 있다.   경험적 배제 기법의 핵심은 더 이상 탐색할 필요가 없는 지점을 판단하는 기준을 정하는 것이다. 이 판단의 근거는 일반적으로 탐색 중에 얻을 수 있는 정보를 활용하는 경우가 대부분이다. 앞에서 다루었던 전체탐색법의 예제들 중 분기한정으로 효율을 향상시킬 수 있는 예제를 통하여 조건을 설정하는 방법을 익혀보자.   연구활동 가는 길      *위의 그래프를 참고하여 문제를 풀어보자*  정올이는 GSHS에서 연구활동 교수님을 뵈러 A대학교를 가려고 한다. 출발점과 도착점을 포함하여 경유하는 지역 n개, 한 지역에서 다른 지역으로 가는 방법이 총 m 개이며  GSHS는 지역 1이고 A대학교는 지역 n이라고 할 때 대학까지 최소 비용을 구하시오.  단, n은 10 이하, m은 30 이하, 그리고 한 지역에서 다른 지역으로  가는 데에 필요한 비용은 모두 200 이하 양의 정수이며 한 지역에서 다른 지역으로 가는 어떠한 방법이 존재하면  같은 방법과 비용을 통해 역방향으로 갈 수 있다.  위의 그래프는 예를 보여준다. (단, 정점a-&gt;정점b로의 간선이 여러 개 있을 수 있으 며, 자기 자신으로 가는 정점을 가질 수도 있다.)  최소 비용이 드는 경로 : 1→3→5→7, 최소 비용 : 69+59+21=149  입력 첫 번째 줄에는 정점의 수 n과 간선의 수 m이 공백으로 구분되어 입력된다. 다음 줄부터 m개의 줄에 걸쳐서 두 정점의 번호와 가중치가 입력된다. (자기 간선, 멀티 간선이 있을 수 있다.)  출력 대학까지 가는 데 드는 최소 비용을 출력한다. 만약 갈 수 없다면 “-1”을 출력.  ---------------------------- 입력 예  7 11 1 2 47 1 3 69 2 4 57 2 5 124 3 4 37 3 5 59 3 6 86 4 6 27 4 7 94 5 7 21 6 7 40  출력 예 149    이 문제는 앞에서 전체탐색법으로 이미 해결했던 문제이다. 하지만 여기서 탐색을 배제 할 조건을 설정하여 탐색영역을 줄여보자. 먼저 탐색배제 조건을 설정해야 한다. 이 문제에서는 전체의 최소 이동거리를 구하는 것이므로 탐색 중 임의의 한 경로를 찾았을 때마다 새로운 거리를 구할 수 있으므로 탐색 중 다음과 같은 배제 조건을 설정할 수 있다.   현재 탐색한 거리 &gt; 지금까지 구한최소 경로의 거리  위 조건을 만족할 경우, 더 이상 탐색하지 않더라도 해를 구하는 데 전혀 문제가 없음을 알 수 있다. 이 조건을 적용하여 탐색하는 과정의 일부를 살펴보자.      위와 같은 단계를 거치면서 진행하게 되면 해는 점점 더 좋아지고 커팅의 효율은 더 높아진다.  위의 방법으로 작성한 소스코드는 다음과 같다.   #include &lt;stdio.h&gt; int n, m, G[11][11], sol=0x7fffffff, chk[11]; void solve(int V, int W) {   if(W&gt;sol) return;   if(V==n) {     if(W&lt;ol) sol=W;     return;   }   for(int i=1; i&lt;=n; i++)     if(!chk[i] &amp;&amp; G[V][i]) {       chk[i]=1;       solve(i, W+G[V][i]);       chk[i] = 0;       }    } int main(void) {   scanf(\"%d %d\", &amp;n, &amp;m);    for(int i=0; i&lt;m; i++) {     int s,e,w;     scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);      G[s][e]=G[e][s]=w;   }   solve(1, 0);   printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);   return 0; }   성능 검증을 하기 위하여 counter이라는 변수를 이용하여 해를 구하기까지 몇 개의 상태를 탐색하는지 카운팅하는 프로그램을 작성하고, 3번의 임의의 입력데이터를 이용하여 테스트를 해 보자.   검증하는 프로그램과 검증 데이터 셋은 다음과 같다.   #include &lt;stdio.h&gt; int n, m, G[11][11], sol=0x7fffffff, chk[11]; int counter; // 추가 void solve(int V, int W) {   if(W&gt;sol) return;   counter++;  // 추가   if(V==n) {     if(W&lt;ol) sol=W;     return;   }   for(int i=1; i&lt;=n; i++)     if(!chk[i] &amp;&amp; G[V][i]) {       chk[i]=1;       solve(i, W+G[V][i]);       chk[i] = 0;       }    } int main(void) {   scanf(\"%d %d\", &amp;n, &amp;m);    for(int i=0; i&lt;m; i++) {     int s,e,w;     scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);      G[s][e]=G[e][s]=w;   }   solve(1, 0);      printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);   printf(\"[탐색한 정점 수 %d개]\\n\", counter);    return 0; }   다음은 테스트 한 입력데이터 3개이다.   입력 1  5 7 1 2 2 1 3 10 1 4 7 2 5 4 2 3 6 4 5 3 3 5 4  입력 2 5 8 1 2 2 1 3 1 1 4 3  2 5 2 2 3 1 4 5 3 3 5 2  1 5 14  입력 3 7 11 1 2 47 1 3 69 2 4 57 2 5 124 3 4 37 3 5 59 3 6 86 4 6 27 4 7 94  5 7 21  6 7 40    위 3개의 데이터에 대한 결과이다.      다음은 배제된 공간의 비율을 보여준다.      위 표에서 알 수 있듯이 탐색한 정점의 수가 많이 줄어든 것을 알 수 있다. 대략적으로 원래 방법보다는 2배 이상 빨라졌음을 알 수 있다. 이는 데이터의 특성에 따라 달라질 수 있으니 참고하기 바란다.   이와 같은 알고리즘의 효율은 처음에 구한 해가 얼마나 질이 좋은 해인가에 따라 결정된다. 그렇다면 초반에 질이 좋은 해를 어떻게 구할 수 있을까? 앞에서 다룬 내용 중에 단순 탐욕법이라는 것이 있었다. 이는 현재 상태에서 수학적인 검증 없이 가장 유리한 상태만을 탐색하는 방법이다. 이 방법이 최적해를 구할 수는 없지만 비교적 질이 좋은 해를 구할 수 있다는 사실을 다루었다.   따라서 단순 탐욕법을 이용하여 처음에 하나의 해를 구한다. 일반적으로 이 해가 품질이 좋을 확률이 높으므로 이 해를 처음해로 탐색배제 조건의 기준이 된다. 그리고 위 알고리즘을 실행하면 평균적인 효율이 향상될 가능성이 크다.   단순 탐욕법으로 처음 해를 구하는 소스코드를 추가한 알고리즘은 다음과 같다.   #include &lt;stdio.h&gt; int n, m, G[1001][1001], sol, chk[1001], greedy_chk[1001];  void greedy_ans(int V) {   int W=0, t;   greedy_chk[V]=1;    while(V!=n) {     int min=0x7fffffff;     for(int i=1; i&lt;=n; i++)       if(!greedy_chk[i] &amp;&amp; G[V][i] &amp;&amp; G[V][i]&lt;min) {         greedy_chk[i]=1;         min=G[V][i];         t=i;       }     sol+=G[V][t];     V=t;   } }  void solve(int V, int W) {   if(W&gt;sol) return; // bounding (cutting)   if(V==n) {     if(W&lt;sol) sol=W;     return;   }   for(int i=1; i&lt;=n; i++)     if(!chk[i] &amp;&amp; G[V][i]) {       chk[i]=1;       solve(i, W+G[V][i]);       chk[i]=0;     }  }  int main(void) {   scanf(\"%d %d\", &amp;n, &amp;m);   for(int i=0; i&lt;m; i++) {     int s,e,w;     scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;w);     G[s][e]=G[e][s]=w;   }   greedy_ans(1);   solve(1, 0);   printf(\"%d\\n\", sol==0x7fffffff ? ‐1:sol);   return 0; }   위 알고리즘에서 greedy_ans 함수가 처음 해를 단순 탐욕법으로 구하고 있는 과정을 나타낸다. 단순 탐욕법으로 구한 해는 정답이 아닐 가능성이 크지만, 해의 품질이 좋기 때문에 커팅의 조건으로 적합하다. 단순 탐욕법은 이와 같이 다양한 응용이 가능하다.   마지막으로 전체의 효율을 비교한 결과는 다음과 같다.      다음은 배제된 공간의 비율을 보여준다.      이와 같이 원래 알고리즘 보다 4배 이상 효율이 향상되었음을 알 수 있다. 이와 같이 탐색을 배제하는 방법은 정해진 것이 없고, 여기에서 소개한 방법은 가장 기본적인 배제 방법이다.   여기서 소개한 방법 이외에도 다양한 조건을 설정할 수 있으므로 공간을 배제할 방법을 스스로 설정하여 조건을 추가하면 효율이 좋아질 수 있으므로, 항상 창의적인 사고력을 기를 수 있도록 연습하자.  References      문제해결을 위한 창의적 알고리즘  ","categories": ["Algorithm"],
        "tags": ["Backtracking","Greedy","Data structure","Programming","Brute force"],
        "url": "http://localhost:4000/algorithm/%ED%83%90%EC%83%89%EA%B3%B5%EA%B0%84%EC%9D%98-%EB%B0%B0%EC%A0%9C/",
        "teaser":"http://localhost:4000/assets/images/creativealgorithm33.png"},{
        "title": "유니온 파인드(Union Find, Disjoint Set)",
        "excerpt":"Union-Find  컴퓨터 과학에서 서로소 찾기 집합 혹은 병합 찾기 집합이라 불리며 중복되지 않은 부분집합들의 원소 정보를 조작하고 저장하는 자료구조입니다.   부분집합(Subset)에서 특정 원소 하나를 A, 또 다른 원소 하나를 B라 하겠습니다.  이 A나 B가 어느 부분집합에 속하는지, 또 A와 B가 각각 속한 부분집합 다르다면 이 두 부분집합을 하나의 집합으로 합쳐, 원소들이 Non-overlapping한 하나의 부분집합을 구성하는 것에 목적이 있습니다.   Representation  유니온 파인드 자료구조는 트리로 표현이 될 수 있습니다.  처음 N개의 원소 각각은 서로 다른 1개의 트리이자 부분집합이며 자기 자신이 최상위 루트입니다.  각각의 부분집합을 구별할 땐 그 부분집합의 루트를 이용합니다.  서로 다른 두개의 부분집합을 합칠 땐 하나의 부분집합의 루트를 다른 하나의 부분집합의 루트로 가리키게 합니다.   Union-Find represented as a tree:      우리는 이를  “1 Dimention Array”로 표현이 가능합니다.  index i\t  =  1, 2, 3, 4, 5, 6, 7  parent[i] = [2, 2, 2, 5, 5, 6, 7]  parent[1] = 2 -&gt; 원소 1은 원소 2를 부모로 한다.  parent[6] = 6 -&gt; 원소 6은 6 즉, 자기 자신을 부모로 한다.   Operations   유니온 파인드 자료구조를 위한 연산들을 보겠습니다.   Make set (Initialization)  유니온 파인드 자료구조를 위한 새로운 집합을 생성합니다.  노드 각각이 자기 자신을 가리키도록 설정합니다. (처음에는 자기 자신이 트리의 최상위 노드)   public void makeSet() {    for (int i = 0; i &lt; n; i++)      parent[i] = i; }   Make set operation:      배열의 상태는 아래와 같습니다.   index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [1, 2, 3, 4, 5, 6, 7]   Find  우리는 두 원소가 서로 다른 부분집합에 속해있으면 두 부분집합을 Union 할 수 있습니다.  두 원소가 서로 같은 부분집합에 포함되어 있는지 아닌지 확인하기 위해 두 원소의 루트를 확인해야 합니다.  Find 연산은 해당 원소가 속해있는 부분집합의 루트를 반환합니다.      원소 x의 부모가 자기 자신이라면 그 부분집합의 루트이므로 x를 반환합니다.   아니라면 재귀 호출로 x의 부모를 따라갑니다.   루트를 찾을 때까지 재귀 호출이 진행되다가 루트를 찾으면 원소 x의 루트를 반환합니다.   int find(x) { // Recursive function     if (parent[x] == x)    // 원소 x의 부모가 자기자신이면 그 부분집합의 루트이므로        return x;        // x를 반환합니다.     else           return find(parent[x]); // 아니라면 x의 부모를 다시 재귀호출하여 루트를 찾습니다. }   Find(1) returns 2:      현재 배열의 상태입니다.  index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [2, 2, 2, 5, 5, 6, 7]   원소 1이 속한 부분집합의 루트를 알고 싶다면 Find(1)을 수행합니다.  parent[1] != 1  두 값이 같지 않습니다.  그럼 parent[1]을 매개변수로 다시 Find(parent[1])을 재귀 호출합니다.// 부모를 따라가는 것입니다.  parent[2] == 2 두 값이 같습니다! 2를 반환합니다.   1의 루트는 2 임을 알 수 있습니다.   5를 보겠습니다.  find(5)를 수행하면  parent[5] == 5  두 값이 같습니다.  5의 부모는 5 자기 자신의 값이 되고, 이 말은 자기 자신이 루트란 말이므로 5를 반환합니다.   Union  두 원소가 속한 부분집합이 다르면 두 부분집합을 하나의 부분집합으로 합칠 수 있습니다.  이를 수행하는 연산이 Union입니다.      두 원소(x, y)가 속한 부분집합이 서로 같다면 return 합니다.   같지 않다면 두 부분집합을 합칩니다.   Make set operation:      처음에 이렇게 7개의 서로 다른 부분집합이 있습니다. (자기 자신이 트리의 루트)   Union:      union(2,1), union(4,3), union(6,5)를 수행하면 위 그림처럼 트리가 구성됩니다.  2의 루트는 2이고 1의 루트도 1 자기 자신입니다.  둘의 값이 다르므로 서로 다른 부분집합이고, 2는 1을 가리킴으로써 부분집합을 합칩니다.  union(4,3), union(6,5)도 마찬가지입니다.   아래는 위 트리의 배열 상태입니다.  index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [1, 1, 3, 3, 5, 5, 7]   union(2, 4)를 하면 아래 그림처럼 됩니다.   Union(2, 4):      void union(int x, int y) {     xRoot = find(x) // find로 x의 루트를     yRoot = find(y)      if(xRoot == yRoot) // 두 원소가 속한 부분집합이 같으므로 리턴합니다.       return;     parent[x_root] = y_root; // 두 부분집합을 합칩니다. x의 루트를 y의 루트로 가리키게 합니다. }   2가 속한 부분집합의 루트(find(2))는 1이고, 4가 속한 부분집합의 루트(find(4))는 3이므로, 이 둘의 값이 다르고 1이 3을 가리킴으로써(parent [1] = 3) 같은 부분집합으로 합쳐 줍니다.   아래는 위 트리의 배열 상태입니다.   index i   =  1, 2, 3, 4, 5, 6, 7 parent[i] = [3, 1, 3, 3, 5, 5, 7]   Path compression   부분집합을 합치는 연산(유니온)을 수행하면서 아래 그림과 같이 편향적인 트리로 구성될 수 있습니다.  이때 노드의 개수가 n개일 때 find(n)을 수행하면 시간 복잡도는 O(n)가 됩니다.  아래 그림에서 5번 원소는 자기 부모를 타고 가다가 끝에는 루트 1을 만나게 됩니다. 링크를 4번 타고 가야 루트를 찾을 수 있습니다.  4번 원소도 링크를 3번 타고 가야 루트를 찾을 수 있습니다.   편향 트리:      우리는 여기서 한 가지 개선을 할 수 있습니다.  5번에서 1번 까지(5 - 4 - 3- 2 - 1)의 경로에 있는 모든 원소는 전부 루트를 1로 갖습니다.  그렇다면 5번도 1을, 4번도 1을.. 2번도 1을 가리켜도 이  부분집합을 구성하는 원소는 변함이 없을 것입니다.  이렇게 되면 아래 그림처럼 5번에서 2번까지 1번을 루트로서 바로 가리키게 되고  find(n) 연산 수행 시 시간 복잡도는 상수 시간 O(1)이 됩니다.   이것을 Path compression(경로 압축)이라 합니다.   Union-Find with path compression:      find(5) 연산 수행 시 5에서 루트 1로 가는 경로에 있는 모든 원소를 재귀 호출이나 For loop을 이용해서 1을 루트로 바로 가리키게 구현할 수 있습니다.      x가 x의 부모와 같다면(자기 자신이 루트)라면 x를 반환합니다.   다르다면 x의 부모는 x의 부모의 재귀 리턴 값이 됩니다.   재귀가 진행되면서 루트를 만나게 되면(매개변수로 들어온 값이 자기 자신 = 루트) x를 반환합니다.   int find(x){      if (parent[x] != x)         parent[x] = find(parent[x]);      return x; }   Union by Rank   트리의 깊이 또는 높이는 유니온 파인드 연산 실행시간에 영향을 주는데 트리를 합칠 때 높이가 작은 트리를 높이가 큰 트리의 루트에 붙이면 높이가 높아지지 않습니다. 이렇게 유니온 바이 랭크(union by rank)는 높이가 작은 트리를 큰 트리 루트에 붙이는 방법입니다.   ※ 단, 높이가 같은 트리를 합칠 땐 높이가 +1 높아집니다.   우리는 여기서 랭크라는 표현을 쓰는데, 트리의 높이는 위에서 살펴본 path compresstion에 의해서 줄어들 수 있고 업데이트되지 않기 때문입니다. 그래서 랭크라는 표현을 씁니다.      어떤 원소 u가 한 트리의 루트이고 랭크 r을 가진다고 하면 유니온 바이 랭크 연산 하에  그 트리의 노드 수는 최소 2^r이 되고, 랭크 r로 같은 두 트리를 Union by rank 하면  랭크는 1 높아지게 되고 노드의 수는 2^r + 2^r = 2^(r+1)가 됩니다.  노드의 수는 2배가 되고 랭크는 1 높아지므로 연산 수행 시간이 O(log n)로 보장됩니다.      원소마다 랭크 정보를 유지하기 위해서 Make set의 for loop에 rank [i] = 0을 추가해 줍니다.   for (i=1; i&lt;=n; i++){     parent[i] = i;     rank[i] = 0; // 처음에는 랭크가 전부 0 }  아래는 union by rank코드입니다.      두 원소의 루트를 구해서 서로 같다면 합치지 않고 유니온 연산을 종료합니다.   그렇지 않다면, x의 루트랭크가 y의 루트랭크보다 크거나 같다면 y의 루트를 x의 루트 아래로 붙입니다. (else 서로 스왑해서 수행)   두 트리의 랭크가 서로 같다면 랭크+1을 해줍니다. (두 트리의 랭크가 같으니 합치면 랭크가 +1 됩니다.)   void union(int x, int y)      xRoot = find(x);      yRoot = find(y);      if xRoot == yRroot          return        if (rank[xRoot] &gt;= rank[yRoot])          parent[yRoot] = xRoot;      else          parent[xRoot] = yRoot;        if (rank[xRoot] == rank[yRoot])          rank[yRoot] = rank[xRroot] + 1   Application   유니온 파인드는 무향 그래프에서의 사이클 존재 유무를 판별할 때 사용될 수 있습니다. (단, 셀프 루프는 없어야 합니다.)   또, 크루스칼 알고리즘에서 최소 스패닝 트리를 찾는데에 사용됩니다.   최소 스패닝 트리는 노드의 수가 n개 일 때 n-1개의 최소 비용의 간선으로 이루어진 트리로서 그래프에서 최소비용의 간선을 선택함에 있어 만들어지는 트리에서 사이클이 존재하지 않아야 하기에 사이클을 형성 유무 판별에 유니온 파인드가 사용됩니다.   Union by Lank with Path Compression   class unionFind{     private int parent[];     private int rank[];     private int n;       unionFind(int cnt) {         this.n = cnt;         parent = new int[n];         rank = new int[n];     }       public void makeSet() {         for (int i = 0; i &lt; n; i++) {             parent[i] = i;             rank[i] = 0;         }     }       public int find(int x) {         if (parent[x] == x)             return x;         else             return parent[x] = find(parent[x]); // * 경로 압축     }       public void union(int root1, int root2) {         root1 = find(root1);         root2 = find(root2);           if (root1 == root2) // 루트가 같다면 수행하지 않는다.             return;           if (rank[root1] &gt;= rank[root2]) { // 루트1의 랭크가 루트2의 랭크보다 크다면             parent[root2] = parent[root1]; //루트2가 루트1의 밑으로 합친다         } else { // 위의 if문 과 반대             parent[root1] = parent[root2];         }         if (rank[root1] == rank[root2])             rank[root1]+=1;     } }   백준 온라인 저지에 있는 유니온 파인드 문제 1717번 집합의 표현 코드입니다.   BOJ - 1717번  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer;  public class Main {     public static void main(String[] args) throws IOException {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));         StringTokenizer st = new StringTokenizer(br.readLine());         StringBuilder sb = new StringBuilder();         int n = Integer.parseInt(st.nextToken());         int m = Integer.parseInt(st.nextToken());         unionFind h = new unionFind(n+1);         h.makeSet();         for (int i = 0; i &lt; m; i++) {             st = new StringTokenizer(br.readLine());             int operation = Integer.parseInt(st.nextToken());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());             if(operation == 0)                 h.union(a ,b);             else                 sb = h.find(a) == h.find(b) ?                  sb.append(\"YES\").append(\"\\n\") : sb.append(\"NO\").append(\"\\n\");         }         System.out.println(sb.toString());     } }  class unionFind {     private int parent[];     private int rank[];     private int n;      unionFind(int cnt) {         this.n = cnt;         parent = new int[n];         rank = new int[n];     }      public void makeSet() {         for (int i = 0; i &lt; n; i++) {             parent[i] = i;             rank[i] = 0;         }     }      public int find(int x) {         if (parent[x] == x)             return x;         else             return parent[x] = find(parent[x]); // * 경로 압축     }      public void union(int root1, int root2) {         root1 = find(root1);         root2 = find(root2);          if (root1 == root2) // 루트가 같다면 수행하지 않는다.             return;          if (rank[root1] &gt;= rank[root2]) { // 루트1의 랭크가 루트2의 랭크보다 크다면             parent[root2] = parent[root1]; //루트2가 루트1의 밑으로 합친다         } else { // 위의 if문 과 반대             parent[root1] = parent[root2];         }         if (rank[root1] == rank[root2])             rank[root1]+=1;     } }   References  Wikipedi - Union Find Algocoding - Union Find  ","categories": ["Data Structure"],
        "tags": ["programming","Data Structure"],
        "url": "http://localhost:4000/data%20structure/unionfind/",
        "teaser":"http://localhost:4000/assets/images/withoutunionbylank.png"}]
